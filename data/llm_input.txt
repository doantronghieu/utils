
Most of the time, you don’t want everyone on the internet to have access to your API, without any restrictions on the data they can create or read. That’s why you’ll need to at least protect your application with a private token or have a proper authentication system to manage the rights given to each user. In this chapter, we’ll see how FastAPI provides security dependencies to help us retrieve credentials by following different standards that are directly integrated into the automatic documentation. We’ll also build a basic user registration and authentication system to secure our API endpoints.

Finally, we’ll cover the security challenges you must tackle when you want to call your API from a web application in a browser – in particular, the risks of CORS and CSRF attacks.

In this chapter, we’re going to cover the following main topics:
Security dependencies in FastAPI
Retrieving a user and generating an access token
Securing API endpoints for authenticated users
Securing endpoints with access tokens
Configuring CORS and protecting against CSRF attacks

# Security dependencies in FastAPI

To protect REST APIs, and HTTP endpoints more generally, lots of standards have been proposed. Here is a non-exhaustive list of the most common ones:

Basic HTTP authentication: In this scheme, user credentials (usually, an identifier such as an email address and password) are put into an HTTP header called Authorization. The value consists of the Basic keyword, followed by the user credentials encoded in Base64. This is a very simple scheme to implement but not very secure since the password appears in every request.

Cookies: Cookies are a useful way to store static data on the client side, usually on web browsers, that is sent in each request to the server. Typically, a cookie contains a session token that can be verified by the server and linked to a specific user.

Tokens in the Authorization header: Probably the most used header in a REST API context, this simply consists of sending a token in an HTTP Authorization header. The token is often prefixed by a method keyword, such as Bearer. On the server side, this token can be verified and linked to a specific user.

Each standard has its pros and cons and is suitable for a specific use case.

As you already know, FastAPI is mainly about dependency injection and callables that are automatically detected and called at runtime. Authentication methods are no exception: FastAPI provides most of them out of the box as security dependencies.

First, let’s learn how to retrieve an access token in an arbitrary header. For this, we can use the ApiKeyHeader dependency, as shown in the following example:

In this simple example, we hardcoded a token, API_TOKEN, and checked whether the token passed in the header was equal to this token, before authorizing the endpoint to be called. To do this, we used the APIKeyHeader security dependency, which is designed to retrieve a value from a header. It’s a class dependency that can be instantiated with arguments. In particular, it accepts the name argument, which holds the name of the header it’ll look for.

Then, in our endpoint, we injected this dependency to get the token’s value. If it’s equal to our token constant, we proceed with the endpoint logic. Otherwise, we raise a 403 error.

Our example from the Path, router, and global dependencies section of Chapter 5, Dependency Injection in FastAPI, is not very different from this one. We are simply retrieving a value from an arbitrary header and making an equality check. So, why bother with a dedicated dependency? There are two reasons:
First, the logic to check whether the header exists and retrieve its value is included in APIKeyHeader. When you reach the endpoint, you are sure that a token value was retrieved; otherwise, a 403 error will be thrown.
The second, and probably most important, thing is that it’s detected by the OpenAPI schema and included in its interactive documentation. This means that endpoints using this dependency will display a lock icon, showing that it’s a protected endpoint. Furthermore, you’ll have access to an interface to input your token, as shown in the following screenshot. The token will then be automatically included in the requests you are making from the documentation:

Of course, you can wrap the logic that checks the token value in its own dependency to reuse it across your endpoints, as shown in the following example:

These kinds of dependencies are very good candidates to be used as routers or global dependencies to protect whole sets of routes, as we saw in Chapter 5, Dependency Injection in FastAPI.

This is a very basic example of adding authorization to your API. In this example, we don’t have any user management; we are only checking that a token corresponds to a constant value. While it could be useful for private microservices that are not intended to be called by end users, this approach should not be considered very secure.

First, make sure your API is always served using HTTPS to ensure your token is not exposed in the headers. Then, if it’s a private microservice, you should also consider not exposing it publicly on the internet and making sure only trusted servers can call it. Since you don’t need users to make requests to this service, it’s much safer than a simple token key that could be stolen.

Of course, most of the time, you’ll want to authenticate real users with their own individual access tokens with which they can access their own data. You have probably already used a service that implements this very typical pattern:
First, you must register an account on this service, usually by providing your email address and a password.
Next, you can log in to the service using the same email address and password. The service checks whether the email address exists and that the password is valid.
In exchange, the service provides you with a session token that can be used on subsequent requests to authenticate yourself. This way, you don’t have to provide your email address and password on each request, which would be annoying and dangerous. Usually, such session tokens have a limited lifetime, which means you’ll have to log in again after some time. This mitigates any security risks if the session token is stolen.

In the next section, you’ll learn how to implement such a system.

# Storing a user and their password securely in a database

Storing a user entity in a database is no different from storing any other entity, and you can implement this in the same way as in Chapter 6, Databases and Asynchronous ORMs. The only thing you must be extremely cautious about is password storage. You must not store the password as plain text in your database. Why? If, unfortunately, a malicious person manages to get into your database, they’ll be able to get the passwords of all your users. Since many people use the same password multiple times, the security of their accounts on other applications and websites would be seriously compromised.

To avoid a disaster like this, we can apply cryptographic hash functions to the password. The goal of those functions is to transform the password string into a hash value. This is designed to make it near impossible to retrieve the original data from the hash. Hence, even if your database is compromised, the passwords are still safe.

When users try to log in, we simply compute the hash of the password they input and compare it with the hash we have in our database. If they match, this means it’s the right password.

Now, let’s learn how to implement such a system with FastAPI and SQLAlchemy ORM.

## Creating models

We start by creating the SQLAlchemy ORM model for a user, as shown in the following example:

To keep this example simple, we’re only considering the ID, email address, and password in our model. Note that we added a unique constraint to the email column to ensure we can’t have duplicate emails in our database.

Next, we can implement the corresponding Pydantic schemas:

As you can see, there is a major difference between UserCreate and User: the former accepts the plain text password we’ll hash during registration, while the second will only keep the hashed password in the database. We also take care to not include hashed_password in UserRead, so the hash doesn’t appear in API responses. Even though hashed data should be indecipherable, it’s generally not advised to leak it.

## Hashing passwords

Before we look at the registration endpoint, let’s implement some important utility functions for hashing passwords. Fortunately, libraries exist that provide the most secure and efficient algorithms for this task. Here, we’ll use passlib. You can install it along with argon2_cffi, which is one of the safest hash functions at the time of writing:

Now, we’ll just instantiate the passlib classes and wrap some of their functions to make our lives easier:

CryptContext is a very useful class since it allows us to work with different hash algorithms. If, one day, a better algorithm than argon2 emerges, we can just add it to our allowed schemas. New passwords will be hashed using the new algorithm, but existing passwords will still be recognized (and optionally upgraded to the new algorithm).

## Implementing registration routes

Now, we have all the elements to create a proper registration route. Once again, it’ll be very similar to what we saw earlier. The only thing we must remember is to hash the password before inserting it into our database.
Let’s look at the implementation:

As you can see, we are calling get_password_hash on the input password before inserting the user into the database. Note that we are catching a possible exc.IntegrityError exception, which means we’re trying to insert an email that already exists.

Also, notice that we took care to set response_model to UserRead. By doing this, we’re ensuring that hashed_password is not part of the output.

Great! We now have a proper user model and users can create a new account with our API. The next step is to allow them to log in and give them an access token.

# Retrieving a user and generating an access token

After successful registration, the next step is being able to log in: the user will send their credentials and receive an authentication token to access the API. In this section, we’ll implement the endpoint that allows this. Basically, we’ll get the credentials from the request payload, retrieve the user with the given email, and verify their password. If the user exists and their password is valid, we’ll generate an access token and return it in the response.

## Implementing a database access token

First, let’s think about the nature of this access token. It should be a data string that uniquely identifies a user that is impossible to forge by a malicious third party. In this example, we will take a simple but reliable approach: we’ll generate a random string and store it in a dedicated table in our database, with a foreign key referring to the user.

This way, when an authenticated request arrives, we simply have to check whether it exists in the database and look for the corresponding user. The advantage of this approach is that tokens are centralized and can easily be invalidated if they are compromised; we only need to delete them from the database.

The first step is to implement the SQLAlchemy ORM model for this new entity:

We define three columns:
access_token: This is the string that will be passed in the requests to authenticate them. Notice that we defined the generate_token function as the default factory; it’s a simple function defined previously that generates a random secure passphrase. Under the hood, it relies on the standard secrets module.
user_id: A foreign key referring to the users table that identifies the user corresponding to this token.
expiration_date: The date and time when the access token will expire and won’t be valid anymore. It’s always a good idea to give access tokens an expiry date to mitigate the risk if they are stolen. Here, the get_expiration_date factory sets a default validity of 24 hours.

We also don’t forget to define the relationship so we can directly access the user entity from an access token object. Notice we set an eager loading strategy by default, so we always retrieve the user when querying for an access token. If you need the rationale behind this, check the Adding relationships section of Chapter 6, Databases and Asynchronous ORMs.

We won’t need Pydantic schemas here, as access tokens will be created and serialized through specific methods.

## Implementing a login endpoint

Now, let’s think about the login endpoint. Its goal is to take credentials in the request payload, retrieve the corresponding user, check the password, and generate a new access token. Its implementation is quite straightforward, apart from one thing: the model that’s used to handle the request. You’ll see why thanks to the following example:

As you can see, we retrieve the request data thanks to the OAuth2PasswordRequestForm module, which is provided by FastAPI in its security module. It expects several fields, especially username and password, in a form encoding rather than JSON.

Why do we use this class? The main benefit of using this class is that it’s completely integrated into the OpenAPI schema. This means that the interactive documentation will be able to automatically detect it and present a proper authentication form behind the Authorize button, as shown in the following screenshot:

But that’s not all: it will be able to automatically retrieve the returned access token and set the proper authorization header in subsequent requests. The authentication process is handled transparently by the interactive documentation.

This class follows the OAuth2 protocol, which means you also have fields for the client ID and secret. We won’t learn how to implement the complete OAuth2 protocol here, but note that FastAPI provides all the tools needed to do so properly. For our project, we’ll just stick with a username and a password. Notice that, following the protocol, the field is named username, regardless of whether we are using an email address to identify the user. This isn’t a big deal; we just have to remember it while retrieving it.

The rest of the path operation function is quite simple: first, we try to retrieve a user from this email and password. If no corresponding user is found, we raise a 401 error. Otherwise, we generate a new access token before returning it. Notice that the response structure also includes the token_type property. This allows the interactive documentation to automatically set the authorization headers.

In the following example, we’ll look at the implementation of the authenticate and create_ access_token functions. We won’t go into too much detail here as they are quite simple:

Notice that we defined a function called verify_password to check the validity of the password. Once again, it uses passlib under the hood, which takes care of comparing the hashes of the passwords.

Password hash upgrade To keep this example simple, we implemented a simple password comparison. Usually, it’s good practice to implement a mechanism to upgrade the password hash at this stage. Imagine that a new and more robust hash algorithm has been introduced. We can take this opportunity to hash the password with this new algorithm and store it in a database. passlib includes a function for verifying and upgrading the hash in one operation. You can learn more about this in the following documentation: https://passlib.readthedocs.io/en/stable/ narr/context-tutorial.html#integrating-hash-migration.

We’ve almost achieved our goal! Users can now log in and get a new access token. All we need to do now is implement a dependency to retrieve the Authorization header and verify this token!

## Securing endpoints with access tokens

Previously, we learned how to implement a simple dependency to protect an endpoint with a header. Here, we’ll also retrieve a token from a request header, but then, we’ll have to check the database to see whether it’s valid. If it is, we’ll return the corresponding user.

Let’s see what our dependency looks like:

The first thing to notice is that we used the OAuth2PasswordBearer dependency from FastAPI. It goes hand in hand with OAuth2PasswordRequestForm, which we saw in the previous section. It not only checks for the access token in the Authorization header, but it also informs the OpenAPI schema that the endpoint to get a fresh token is /token. This is the purpose of the tokenUrl argument. This is how the automatic documentation can automatically call the access token endpoint in the login form we saw earlier.

Then we performed a database query with SQLAlchemy. We applied two clauses: one to match the token we got and another to ensure that the expiration date is in the future. If no corresponding record is found in the database, we raise a 401 error. Otherwise, we return the user related to the access token.

And that’s it! Our whole authentication system is complete. Now, we can protect our endpoints simply by injecting this dependency. We even have access to the user data so that we can tailor the response according to the current user. You can see this in the following example:

With that, you’ve learned how to implement a whole registration and authentication system from scratch. We voluntarily kept it simple to focus on the most important points, but it’s a good base on which you can expand.

The patterns we showed here are good candidates for a REST API, which is called externally by other client programs. However, you may wish to call your API from a very common piece of software: the browser. In this case, there are some additional security considerations to be taken care of.

# Configuring CORS and protecting against CSRF attacks

Nowadays, numerous pieces of software are designed to be used in a browser through an interface built with HTML, CSS, and JavaScript. Traditionally, web servers were responsible for handling browser requests and returning an HTML response to be shown to the user. This is a common use case for frameworks such as Django.

For a few years now, there has been a shift underway in that pattern. With the emergence of JavaScript frameworks such as Angular, React, and Vue, we tend to have a clear separation between the frontend, a highly interactive user interface powered by JavaScript, and the backend. Thus, those backends are now only responsible for data storage and retrieving and executing business logic. This is a task that REST APIs are very good at! From the JavaScript code, the user interface can then just spawn requests to your API and handle the result to present it.

However, we must still handle authentication: we want our user to be able to log in to the frontend application and make authenticated requests to the API. While an Authorization header, as we’ve seen so far, could work, there is a better way to handle authentication when working in browsers: cookies!

Cookies are designed to store user information in browser memory and are sent automatically in every request made to your server. They have been supported for years, and browsers integrate lots of mechanisms to make them safe and reliable.

However, this comes with some security challenges. Websites are very common targets for hackers and lots of attacks have emerged over the years.

One of the most typical is Cross-Site Request Forgery (CSRF). In this scenario, an attacker on another website tries to trick a user who is currently authenticated with your application to perform a request on your server. Since browsers tend to send cookies with every request, your server wouldn’t be able to tell that the request was actually forged. Since it’s the users themselves who unintentionally launched the malicious request, these kinds of attacks don’t aim to steal data but to execute operations that change the state of the application, such as changing an email address or making a money transfer.

Obviously, we should be prepared for these kinds of risks and have measures in place to mitigate them.

## Understanding CORS and configuring it in FastAPI

When you have a clearly separated frontend application and a REST API backend, they are not typically served from the same subdomain. For example, the frontend may be available from www. myapplication.com, while the REST API is available from api.myapplication.com. As we mentioned in the introduction, we would like to make requests to this API from our frontend application in JavaScript.

However, browsers don’t allow cross-origin resource sharing (CORS) HTTP requests, meaning domain A can’t make requests to domain B. This follows what is called a same-origin policy. This is a good thing in general as it’s the first barrier to preventing CSRF attacks.

To experience this behavior, we’ll run a simple example. In our example repository, the chapter07/ cors folder contains a FastAPI app called app_without_cors.py and a simple HTML file called index.html that contains some JavaScript for performing HTTP requests.

First, let’s run the FastAPI application using the usual uvicorn command:
This will launch the FastAPI application on port 8000 by default. On another terminal, we’ll serve the HTML file using the built-in Python HTTP server. It’s a simple server, but it’s ideal for quickly serving static files. We can launch it on port 9000 thanks to the following command:

Starting several terminals On Linux and macOS, you should be able to simply start a new Terminal by creating a new window or tab. On Windows and WSL, you can also have several tabs if you’re using the Windows Terminal application: https://apps.microsoft.com/store/detail/ windows-terminal/9N0DX20HK701.
Otherwise, you can simply click on the Ubuntu shortcut in your Start menu to start another terminal.

We now have two running servers – one on localhost:8000 and one on localhost:9000. Strictly speaking, since they are on different ports, they are of different origins; so, it’s a good setup to try out cross-origin HTTP requests.

In your browser, go to http://localhost:9000. You’ll see the simple application implemented in index.html, as shown in the following screenshot:

There are two buttons that initiate GET and POST requests to our FastAPI application on port 8000. If you click on either of those, you’ll get a message in the error area stating Failed to fetch. If you look at the browser console in the development tools section, you’ll see that the request failed because there isn’t a CORS policy, as shown in the following screenshot. That’s what we wanted – by default, browsers block cross-origin HTTP requests:

However, if you look at the terminal running the FastAPI application, you’ll see an output similar to the following:

Clearly, both the GET and POST requests have been received and processed: we even returned a 200 status. So, what does this mean? In this case, the browser does send the request to the server. The lack of a CORS policy only forbids it to read the response; the request is still executed.

This is the case for requests that the browser considers simple requests. In essence, simple requests are those using the GET, POST, or HEAD methods that don’t set custom headers or unusual content types. You can learn more about simple requests and their conditions by going to the following MDN page about CORS: https://developer.mozilla.org/en-US/docs/Web/HTTP/ CORS#simple_requests.

This means that, for simple requests, the same-origin policy is not enough to protect us against CSRF attacks.

You may have noticed that our simple web application has a toggle for Enable JSON content-type. Enable this and perform the GET and POST requests again. On your FastAPI terminal, you should have an output similar to the following:

As you can see, our server received two strange requests with the OPTIONS method. This is what we call preflight requests in the context of CORS policies. Those requests are initiated by the browser before it performs the actual request when it doesn’t consider it as a simple request. Here, we added the Content-Type header with a value of application/json, which is against the conditions of simple requests.

By performing this preflight request, the browser expects the server to provide information about what it is and isn’t allowed to do in terms of cross-origin HTTP requests. Since we’ve not implemented anything here, our server can’t provide a response to this preflight request. Hence, the browser stops there and doesn’t proceed with the actual request.

And that’s basically CORS: the server answers preflight queries with a set of HTTP headers that provide information to the browser about whether it’s allowed to make the request or not. In that sense, CORS doesn’t make your application more secure, it’s quite the contrary: it allows the relaxation of some rules so that a frontend application can make requests to a backend residing on another domain. That’s why it’s crucial to configure CORS properly, so it doesn’t expose you to dangerous attacks.

Fortunately, it’s fairly easy to do this with FastAPI. All we need to do is import and add the CORSMiddleware class provided by Starlette. You can see what this looks like in the following example:

A middleware is a special class that adds global logic to an Asynchronous Server Gateway Interface (ASGI) application performing things before the request is handled by your path operation functions, and also after to possibly alter the response. FastAPI provides the add_middleware method for wiring such middleware into your application.

Here, CORSMiddleware will catch preflight requests sent by the browser and return the appropriate response with the CORS headers corresponding to your configuration. You can see that there are options to finely tune the CORS policy to your needs.

The most important one is probably allow_origins, which is the list of origins allowed to make requests to your API. Since our HTML application is served from http://localhost:9000, this is what we put here in this argument. If the browser tries to make requests from any other origin, it will stop as it’s not authorized to do so by CORS headers.

The other interesting argument is allow_credentials. By default, browsers don’t send cookies for cross-origin HTTP requests. If we wish to make authenticated requests to our API, we need to allow this via this option.

We can also finely tune the allowed methods and headers that are sent in the request. You can find a complete list of arguments for this middleware in the official Starlette documentation: https:// www.starlette.io/middleware/#corsmiddleware.

Let’s quickly talk about the max_age parameter. This parameter allows you to control the cache duration of the CORS responses. Having to perform a preflight request before the actual one is an expensive operation. To improve performance, browsers can cache the response so that they don’t have to do this every time. Here, we are disabling caching with a value of -1 to make sure you see the behavior of the browser in this example. In your projects, you can remove this argument so that you have a proper cache value.

Now, let’s see how our web application behaves with this CORS-enabled application. Stop the previous FastAPI app and run this one using the usual command:

Now, if you try to perform the requests from the HTML application, you should see a working response in each case, both with and without a JSON content type. If you look at the FastAPI terminal, you should see an output similar to the following:

The two first requests are the “simple requests,” which don’t need a preflight request according to the browser rules. Then, we can see the requests that were performed with the JSON content type enabled. Before the GET and POST requests, an OPTIONS request was performed: the preflight request!

Thanks to this configuration, you can now make cross-origin HTTP requests between your frontend application and your backend living on another origin. Once again, it’s not something that’ll improve the security of your application, but it allows you to make this specific scenario work while keeping it secure from the rest of the web.

Even if those policies can be a first layer of defense against CSRF, this doesn’t mitigate the risk completely. Indeed, the “simple requests” are still an issue: POST requests are allowed and, even if the response cannot be read, it’s actually executed on the server.

Now, let’s learn how to implement a pattern so that we’re completely safe from such attacks: the double-submit cookie.

## Implementing double-submit cookies to prevent CSRF attacks

As we mentioned previously, when relying on cookies to store user credentials, we are exposed to CSRF attacks since browsers will automatically send the cookies to your server. This is especially true for what the browser considers “simple requests,” which don’t enforce the CORS policy before the request is executed. There are also other attack vectors involving traditional HTML form submissions or even the src attribute of the image tag.

For all these reasons, we need to have another layer of security to mitigate this risk. Once again, this is only necessary if you plan to use your API from a browser application and use cookies for authentication.

To help you understand this, we’ve built a new example application that uses a cookie to store the user access token. It’s very similar to the one we saw at the beginning of this chapter; we only modified it so that it looks for the access token in a cookie rather than in a header.

To make this example work, you’ll have to install the starlette-csrf library. We’ll explain what it does a bit later in this section. For now, just run the following command:

In the following example, you can see the login endpoint that sets a cookie with the access token value:

Notice that we used the Secure and HttpOnly flags for the resulting cookie. This ensures that it’s sent only over HTTPS and that its value can’t be read from JavaScript, respectively. While this is not enough to prevent every kind of attack, it’s crucial for such sensitive information.

Besides that, we also set the SameSite flag to lax. It’s a quite recent flag that allows us to control how the cookie is sent in a cross-origin context. lax is the default value in most browsers and allows the cookie to be sent to subdomains of the cookie domain but prevents it for other sites. In a sense, it’s designed to be the standard, built-in protection against CSRF. However, other CSRF mitigation techniques, such as the one we’ll implement here, are still needed currently. Indeed, older browsers that are not compatible with the SameSite flag are still vulnerable.

Now, when checking for the authenticated user, we’ll just have to retrieve the token from the cookie that was sent in the request. Once again, FastAPI provides a security dependency to help with this, called APIKeyCookie. You can see it in the following example:

And that’s basically it! The rest of the code remains the same. Now, let’s implement an endpoint that allows us to update the email address of the authenticated user. You can see this in the following example:

The implementation is not very surprising and follows what we’ve seen so far. However, it exposes us to a CSRF threat. As you can see, it uses the POST method. If we make a request in the browser to this endpoint without any special header, it will consider it as a simple request and execute it. Therefore, an attacker could change the email of a currently authenticated user, which is a major threat.

This is exactly why we need CSRF protection here. In the context of a REST API, the most straightforward technique is the double-submit cookie pattern. Here is how it works:
1. The user makes a first request with a method that’s considered safe. Typically, this is a GET request.
2.
In response, it receives a cookie containing a secret random value – that is, the CSRF token.
3. When making an unsafe request, such as POST, the user will read the CSRF token in the cookies and put the exact same value in a header. Since the browser also sends the cookies it has in memory, the request will contain the token both in the cookie and the header. That’s why it’s called double submit.
4. Before processing the request, the server will compare the CSRF token provided in the header with the one present in the cookie. If they match, it will proceed to process the request. Otherwise, it’ll throw an error.

This is safe for two reasons:
An attacker targeting a third-party website can’t read the cookies for a domain they don’t own. Thus, they have no way of retrieving the CSRF token value.
Adding a custom header is against the conditions of “simple requests.” Hence, the browser will have to make a preflight request before sending the request, enforcing the CORS policy.

This is a widely used pattern that works well to prevent such risks. This is why we installed starlette- csrf at the beginning of this section: it provides a piece of middleware for implementing it.
We can use it just like any other middleware, as shown in the following example:

We set several important arguments here. First, we have the secret, which should be a strong passphrase that’s used to sign the CSRF token. Then, we have sensitive_cookies, which is a set of cookie names that should trigger the CSRF protection. If no cookie is present or if the provided ones are not critical, we can bypass the CSRF check. It’s also useful if you have other authentication methods available that don’t rely on cookies, such as Authorization headers, which are not vulnerable to CSRF. Finally, setting a cookie domain will allow you to retrieve the cookie containing the CSRF token, even if you are on a different subdomain; this is necessary in a cross-origin situation.

That’s all you need to have the necessary protection ready. To ease the process of getting a fresh CSRF token, we implemented a minimal GET endpoint called /csrf. Its sole purpose is to provide us with a simple way to set the CSRF token cookie. We can call it directly when we load our frontend application.

Now, let’s try it out in our situation. As we did in the previous section, we’ll run the FastAPI application and the simple HTML application on two different ports. To do this, just run the following commands:

This will run the FastAPI application on port 8000. Now, run the following command:

The frontend application is now live on http://localhost:9000. Open it in your browser. You should see an interface similar to the following:

Here, we’ve added forms to interact with our API endpoints: register, log in get authenticated user, and update the endpoints. If you try them out, they should work without any issue. If you have a look at the requests that were sent in the Network tab of the development tools section, you’ll see that the CSRF token is present in the cookies and in a header called x-csrftoken.

At the top, there is a toggle to prevent the application from sending the CSRF token in the header. If you disable it, you’ll see that all POST operations will result in an error.

Great! We are now safe from CSRF attacks! Most of the work here is done by the middleware, but it’s interesting to understand how it works under the hood and how it protects your application. Bear in mind, however, that it comes with a drawback: it will break the interactive documentation. Indeed, it’s not designed to retrieve the CSRF token from the cookie and put it in the headers in each request. Unless you plan on authenticating in another way (through a token in a header, for example), you won’t be able to directly call your endpoints in the documentation.
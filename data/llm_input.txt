Now it’s time to begin learning about FastAPI! In this chapter, we’ll cover the basics of FastAPI. We’ll go through very simple and focused examples that will demonstrate the different features of FastAPI. Each example will lead to a working API endpoint that you’ll be able to test yourself using HTTPie. In the final section of this chapter, we’ll show you a more complex FastAPI project, with routes split across several files. It will give you an overview of how you can structure your own application.

By the end of this chapter, you’ll know how to start a FastAPI application and how to write an API endpoint. You’ll also be able to handle request data and build a response according to your own logic. Finally, you’ll learn a way to structure a FastAPI project into several modules that will be easier to maintain and work with in the long term.

In this chapter, we’ll cover the following main topics:
Creating the first endpoint and running it locally
Handling request parameters
Customizing the response
Structuring a bigger project with multiple routers

## Creating a first endpoint and running it locally

FastAPI is a framework that is easy to use and quick to write. In the following example, you’ll realize that this is not just a promise. In fact, creating an API endpoint involves just a few lines:

In this example, we define a GET endpoint at the root path, which always returns the {"hello": "world"} JSON response. To do this, we first instantiate a FastAPI object, app. It will be the main application object that will wire all the API routes.
Then, we simply define a coroutine that contains our route logic, the path operation function. Its return value is automatically handled by FastAPI to produce a proper HTTP response with a JSON payload.

Here, the most important part of this code is probably the line starting with @, which can be found above the coroutine definition, the decorator. In Python, a decorator is a syntactic sugar that allows you to wrap a function or class with common logic without compromising readability. It’s roughly equivalent to app.get("/")(hello_world).
FastAPI exposes one decorator per HTTP method to add new routes to the application. The one shown here adds a GET endpoint with the path as the first argument.

Now, let’s run this API. Copy the example to the root of your project and run the following command:

As we mentioned in Chapter 2, Python Programming Specificities, in the Asynchronous I/O section, FastAPI exposes an Asynchronous Server Gateway Interface (ASGI)-compatible application. To run it, we require a web server compatible with this protocol. Uvicorn is a good option to use. It gives a command to quickly start a web server. In the first argument, it expects the dotted namespace of the Python module, which contains your app instance, followed by a colon, :, and, finally, the variable name of your ASGI app instance (in our example, this is app). Afterward, it takes care of instantiating the application and exposing it on your local machine.

Let’s try our endpoint with HTTPie. Open another terminal and run the following command:

It works! As you can see, we did get a JSON response with the payload we wanted, using just a few lines of Python and a command!
One of the most beloved features of FastAPI is the automatic interactive documentation. If you open the http://localhost:8000/docs URL in your browser, you should get a web interface that looks similar to the following screenshot:

FastAPI will automatically list all your defined endpoints and provide documentation about the expected inputs and outputs. You can even try each endpoint directly in this web interface. Under the hood, it relies on the OpenAPI specification and the associated tools from Swagger. You can read more about this on its official website at https://swagger.io/.
That’s it! You’ve created your very first API with FastAPI. Of course, this is just a very simple example, but next, you’ll learn how to handle input data and start making meaningful things!

On the shoulder of giants It’s worth noting that FastAPI is built upon two main Python libraries: Starlette, a low-level ASGI web framework (https://www.starlette.io/), and Pydantic, a data validation library based on type hints (https://pydantic-docs.helpmanual.io/).

## Handling request parameters

The main goal of a representational state transfer (REST) API is to provide a structured way to interact with data. As such, it’s crucial for the end user to send some information to tailor the response they need, such as path parameters, query parameters, body payloads, headers, and so on.

Web frameworks usually ask you to manipulate a request object to retrieve the parts you are interested in and manually apply validation to handle them. However, that’s not necessary with FastAPI! Indeed, it allows you to define all of your parameters declaratively. Then, it’ll automatically retrieve them in the request and apply validation based on the type hints. This is why we introduced type hinting in Chapter 2, Python Programming Specificities: it’s used by FastAPI to perform data validation!

Next, we’ll explore how you can use this feature to retrieve and validate this input data from different parts of the request.

### Path parameters

The API path is the main thing that the end user will interact with. Therefore, it’s a good spot for dynamic parameters. A typical example is to put the unique identifier of an object we want to retrieve, such as /users/123. Let’s examine how to define this with FastAPI:

In this example, we defined an API that expects an integer in the last part of its path. We did this by putting the parameter name in the path around curly braces. Then, we defined this same parameter as an argument for our path operation function. Notice that we add a type hint to specify that the parameter is an integer.

Let’s run this example. You can refer to the previous Creating a first endpoint and running it locally section, to learn how to run a FastAPI app with Uvicorn.

First, we’ll try to make a request that omits our path parameter:

We get a response with a 404 status. That’s expected: our route awaits a parameter after /users, so if we omit it, it simply doesn’t match any pattern.
Let’s now try with a proper integer parameter:

It works! We get a 200 status, and the response does contain the integer we passed in the parameter. Notice that it has been properly cast as an integer.
So, what happens if we pass a value that’s not a valid integer? Let’s find out:

We get a response with a 422 status! Since abc is not a valid integer, the validation fails and outputs an error. Notice that we have a very detailed and structured error response telling us exactly which element caused the error and why. All we need to do to trigger this validation is to type hint our parameter!

Of course, you are not limited to just one path parameter. You can have as many as you want, with different types. In the following example, we’ve added a type parameter of the string type:

This works well, but the endpoint will accept any string as the type parameter.

### Limiting allowed values

So, what if we just want to accept a limited set of values? Once again, we’ll lean on type hinting. Python has a very useful class for this: Enum. An enumeration is a way to list all the valid values for a specific kind of data. Let’s define an Enum class that will list the different types of users:

To define a string enumeration, we inherit from both the str type and the Enum class. Then, we simply list the allowed values as class properties: the property name and its actual string value. Finally, we only have to type hint the type argument with this class:

If you run this example and call the endpoint with a type that is not in the enumeration, you’ll get the following response:

As you can see, you get a nice validation error with the allowed values for this parameter!

### Advanced validation

We can take one step further by defining more advanced validation rules, particularly for numbers and strings. In this case, the type of hint is no longer enough. We’ll rely on the functions provided by FastAPI, allowing us to set some options on each of our parameters. For path parameters, the function is named Path. In the following example, we’ll only allow an id argument that is greater than or equal to 1:

There are several things to pay attention to here: the result of Path is used as a default value for the id argument in the path operation function.

Additionally, you can see that we use the ellipsis syntax as the first parameter of Path. Indeed, it expects the default value for the parameter as the first argument. In this scenario, we don’t want a default value: the parameter is required. Therefore, ellipses are here to tell FastAPI that we don’t want a default value.

Ellipsis doesn’t always mean this in Python Using the ellipsis symbol to specify that a parameter is required, as we show here, is specific to FastAPI: it’s the choice of FastAPI creators to use it like this. In other Python programs, this symbol could be used for another means.

Then, we can add the keyword arguments we are interested in. In our example, we use ge, greater than or equal to, and its associated value. Here is the list of available keywords to validate numbers:
gt: Greater than
ge: Greater than or equal to
lt: Less than
le: Less than or equal to

There are also validation options for string values, which are based on length and regular expression. In the following example, we want to define a path parameter that accepts license plates in the form of AB-123-CD (French license plates). A first approach would be to force the string to be a length of 9 (that is, two letters, a dash, three digits, a dash, and two letters):

Now we just have to define the min_length and max_length keyword arguments, just as we did for the number of validations. Of course, a better solution for this use case is to use a regular expression to validate the license plate number:

Thanks to this regular expression, we only accept strings that exactly match the license plate format. Notice that the regular expression is prefixed with r. Just like f-strings, this is a Python syntax that is used to indicate that the following string should be considered a regular expression.

Parameter metadata Data validation is not the only option accepted by the parameter function. You can also set options that will add information about the parameter in the automatic documentation, such as title, description, and deprecated.

Now you should be able to define path parameters and apply some validation to them. Other useful parameters to put inside the URL are query parameters. We’ll discuss them next.

### Query parameters

Query parameters are a common way to add some dynamic parameters to a URL. You can find them at the end of the URL in the following form: ?param1=foo&param2=bar. In a REST API, they are commonly used on read endpoints to apply pagination, a filter, a sorting order, or selecting fields.

You’ll discover that they are quite straightforward to define with FastAPI. In fact, they use the exact same syntax as path parameters:

You simply have to declare them as arguments of your path operation function. If they don’t appear in the path pattern, as they do for path parameters, FastAPI automatically considers them to be query parameters. Let’s try it:

Here, you can see that we have defined a default value for those arguments, which means they are optional when calling the API. Of course, if you wish to define a required query parameter, simply leave out the default value:

Now, if you omit the format parameter in the URL, you’ll get a 422 error response. Additionally, notice that, in this example, we defined a UsersFormat enumeration to limit the number of allowed values for this parameter; this is exactly what we did in the previous section for path parameters.

We also have access to more advanced validations through the Query function. It works in the same way that we demonstrated in the Path parameters section:

Here, we force the page to be greater than 0 and the size to be less than or equal to 100. Notice how the default parameter value is the first argument of the Query function.
Naturally, when it comes to sending request data, the most obvious way is to use the request body. Let’s examine how it works.

### The request body

The body is the part of the HTTP request that contains raw data representing documents, files, or form submissions. In a REST API, it’s usually encoded in JSON and used to create structured objects in a database.

For the simplest cases, retrieving data from the body works exactly like query parameters. The only difference is that you always have to use the Body function; otherwise, FastAPI will look for it inside the query parameters by default. Let’s explore a simple example where we want to post some user data:

In the same way as query parameters, we define each argument with a type hint along with the Body function with no default value to make them required. Let’s try the following endpoint:

Here, we used the -v option of HTTPie so that you can clearly see the JSON payload we sent. FastAPI successfully retrieves the data for each field from the payload. If you send a request with a missing or invalid field, you’ll get a 422 status error response.

You also have access to more advanced validation through the Body function. It works in the same way as we demonstrated in the Path parameters section.

However, defining payload validations such as this has some major drawbacks. First, it’s quite verbose and makes the path operation function prototype huge, especially for bigger models. Second, usually, you’ll need to reuse the data structure on other endpoints or in other parts of your application.

This is why FastAPI uses Pydantic models for data validation. Pydantic is a Python library for data validation and is based on classes and type hints. In fact, the Path, Query, and Body functions that we’ve learned about so far use Pydantic under the hood!

By defining your own Pydantic models and using them as type hints in your path arguments, FastAPI will automatically instantiate a model instance and validate the data. Let’s rewrite our previous example using this method:

First, we import BaseModel from pydantic. This is the base class that every model should inherit from. Then, we define our User class and list all of the properties as class properties. Each one of them should have a proper type hint: this is how Pydantic will be able to validate the type of the field.

Finally, we just declare user as an argument for our path operation function with the User class as a type hint. FastAPI automatically understands that the user data can be found in the request payload. Inside the function, you have access to a proper user object instance, where you can access individual properties by simply using the dot notation, such as user.name.

Notice that if you just return the object, FastAPI is smart enough to convert it automatically into JSON to produce the HTTP response.

In the following chapter, Chapter 4, Managing Pydantic Data Models in FastAPI, we’ll explore, in more detail, the possibilities of Pydantic, particularly in terms of validation.

### Multiple objects

Sometimes, you might have several objects that you wish to send in the same payload all at once. For example, both user and company. In this scenario, you can simply add several arguments that have been type hinted by a Pydantic model, and FastAPI will automatically understand that there are several objects. In this configuration, it will expect a body containing each object indexed by its argument name:

Here, Company is a simple Pydantic model with a single string name property. In this configuration, FastAPI expects a payload that looks similar to the following:

For more complex JSON structures, it’s advised that you pipe a formatted JSON into HTTPie rather than use parameters. Let’s try this as follows:

And that’s it!
You can even add singular body values with the Body function, just as we saw at the beginning of this section. This is useful if you wish to have a single property that’s not part of any model:

The priority property is an integer between 1 and 3, which is expected beside the user object:

You now have a good overview of how to handle JSON payload data. However, sometimes, you’ll find that you need to accept more traditional-form data or even file uploads. Let’s find out how to do this next!

### Form data and file uploads

Even if REST APIs work most of the time with JSON, sometimes, you might have to handle form- encoded data or file uploads, which have been encoded either as application/x-www-form- urlencoded or multipart/form-data.

Once again, FastAPI allows you to implement this case very easily. However, you’ll need an additional Python dependency, python-multipart, to handle this kind of data. As usual, you can install it with pip:

Then, you can use the FastAPI features that are dedicated to form data. First, let’s take a look at how you can handle simple form data.

### Form data

The method to retrieve form data fields is similar to the one we discussed in the The request body section to retrieve singular JSON properties. The following example is roughly the same as the one you explored there. However, this example expects form-encoded data instead of JSON:

The only difference here is that we use the Form function instead of Body. You can try this endpoint with HTTPie and the --form option to force the data to be form-encoded:

Pay attention to how the Content-Type header and the body data representation have changed in the request. You can also see that the response is still provided in JSON. Unless specified otherwise, FastAPI will always output a JSON response by default, no matter the form of the input data.

Of course, the validation options we saw for Path, Query, and Body are still available. You can find a description for each of them in the Path parameters section.

It’s worth noting that, contrary to JSON payloads, FastAPI doesn’t allow you to define Pydantic models to validate form data. Instead, you have to manually define each field as an argument for the path operation function.
Now, let’s go on to discuss how to handle file uploads.

### File uploads

Uploading files is a common requirement for web applications, whether this is images or documents. FastAPI provides a parameter function, File, that enables this.

Let’s take a look at a simple example where you can directly retrieve a file as a bytes object:

Once again, you can see that the approach is still the same: we define an argument for the path operation function, file, add a type hint, bytes, and then we use the File function as a default value for this argument. By doing this, FastAPI understands that it will have to retrieve raw data in a part of the body named file and return it as bytes.
We simply return the size of this file by calling the len function on this bytes object.

In the code example repository, you should be able to find a picture of a cat: https://github. com/PacktPublishing/ Building-Data-Science-Applications-with-FastAPI- Second-Edition/blob/main/assets/cat.jpg.

Let’s upload it on our endpoint using HTTPie. To upload a file, type in the name of the file upload field (here, it is file), followed by @ and the path of the file you want to upload. Don’t forget to set the --form option:
It works! We have correctly got the size of the file in bytes.

One drawback to this approach is that the uploaded file is entirely stored in memory. So, while it’ll work for small files, it is likely that you’ll run into issues for larger files. Besides, manipulating a bytes object is not always convenient for file handling.

To fix this problem, FastAPI provides an UploadFile class. This class will store the data in memory up to a certain threshold and, after this, will automatically store it on disk in a temporary location. This allows you to accept much larger files without running out of memory. Furthermore, the exposed object instance exposes useful metadata, such as the content type, and a file-like interface. This means that you can manipulate it as a regular file in Python and feed it to any function that expects a file.
To use it, you simply have to specify it as a type hint instead of bytes:

Notice that, here, we return the filename and content_type properties. The content type is especially useful for checking the type of the uploaded file and possibly rejecting it if it’s not one of the types you expect.

You can even accept multiple files by type hinting the argument as a list of UploadFile:
To upload several files with HTTPie, simply repeat the argument. It should appear as follows:

Now, you should be able to handle form data and file uploads in a FastAPI application. So far, you’ve learned how to manage user-facing data. However, there are also very interesting pieces of information that are less visible: headers. We’ll explore them next.

### Headers and cookies

Besides the URL and the body, another major part of the HTTP request are the headers. They contain all sorts of metadata that can be useful when handling requests. A common usage is to use them for authentication, for example, via the famous cookies.

Once again, retrieving them in FastAPI only involves a type hint and a parameter function. Let’s take a look at a simple example where we want to retrieve a header named Hello:

Here, you can see that we simply have to use the Header function as a default value for the hello argument. The name of the argument determines the key of the header that we want to retrieve. Let’s see this in action:

FastAPI was able to retrieve the header value. Since there was no default value specified (we put in an ellipsis), the header is required. If it’s missing, once again, you’ll get a 422 status error response.

Additionally, notice that FastAPI automatically converts the header name into lowercase. Besides that, since header names are usually separated by a hyphen, -, it also automatically converts it into snake case. Therefore, it works out of the box with any valid Python variable name. The following example shows this behavior by retrieving the User-Agent header:

Now, let’s make a very simple request. We’ll keep the default user agent of HTTPie to see what happens:

What is a user agent? The user agent is an HTTP header added automatically by most HTTP clients, such as HTTPie or cURL and web browsers. It’s a way for web servers to identify which kind of application made the request. In some cases, web servers can use this information to adapt the response.

One very special case of the header is cookies. You could retrieve them by parsing the Cookie header yourself, but that would be a bit tedious. FastAPI provides another parameter function that automatically does it for you.

The following example simply retrieves a cookie named hello:

Notice that we type hinted the argument as str | None, and we set a default value of None to the Cookie function. This way, even if the cookie is not set in the request, FastAPI will proceed and not generate a 422 status error response.

Headers and cookies can be very useful tools for implementing authentication features. In Chapter 7, Managing Authentication and Security in FastAPI, you’ll learn that there are built-in security functions that can help you to implement common authentication schemes.

### The request object

Sometimes, you might find that you need to access a raw request object with all of the data associated with it. That’s possible. Simply declare an argument on your path operation function type hinted with the Request class:

Under the hood, this is the Request object from Starlette, which is a library that provides all the core server logic for FastAPI. You can view a complete description of the methods and properties of this object in the official documentation of Starlette (https://www.starlette.io/requests/).

Congratulations! You have now learned all of the basics regarding how to handle request data in FastAPI. As you learned, the logic is the same no matter what part of the HTTP request you want to look at. Simply name the argument you want to retrieve, add a type hint, and use a parameter function to tell FastAPI where it should look. You can even add some validation logic!
In the next section, we’ll explore the other side of a REST API job: returning a response.

## Customizing the response

In the previous sections, you learned that directly returning a dictionary or a Pydantic object in your path operation function was enough for FastAPI to return a JSON response.
Most of the time, you’ll want to customize this response a bit further; for instance, by changing the status code, raising validation errors, and setting cookies. FastAPI offers different ways to do this, from the simplest case to the most advanced one. First, we’ll learn how to customize the response declaratively by using path operation parameters.

### Path operation parameters

In the Creating a first endpoint and running it locally section, you learned that in order to create a new endpoint, you had to put a decorator on top of the path operation function. This decorator accepts a lot of options, including ones to customize the response.

- The status code

The most obvious thing to customize in an HTTP response is the status code. By default, FastAPI will always set a 200 status when everything goes well during your path operation function execution.

Sometimes, it might be useful to change this status. For example, it’s good practice in a REST API to return a 201 Created status when the execution of the endpoint ends up in the creation of a new object.

To set this, simply specify the status_code argument on the path decorator:

The decorator arguments come right after the path as keyword arguments. The status_code option simply expects an integer representing the status code. We could have written status_code=201, but FastAPI provides a useful list in the status sub-module that improves code comprehensiveness, as you can see here.

We can try this endpoint to obtain the resulting status code:
We got our 201 status code.

It’s important to understand that this option to override the status code is only useful when everything goes well. If your input data was invalid, you would still get a 422 status error response.

Another interesting scenario for this option is when you have nothing to return, such as when you delete an object. In this case, the 204 No content status code is a good fit. In the following example, we implement a simple delete endpoint that sets this response status code:

Notice that you can very well return None in your path operation function. FastAPI will take care of it and return a response with an empty body.

In the Setting the status code dynamically section, you’ll learn how to customize the status code dynamically inside the path operation logic.

- The response model

With FastAPI, the main use case is to directly return a Pydantic model that automatically gets turned into properly formatted JSON. However, quite often, you’ll find that there are some differences between the input data, the data you store in your database, and the data you want to show to the end user. For instance, perhaps some fields are private or only for internal use, or perhaps some fields are only useful during the creation process and then discarded afterward.

Now, let’s consider a simple example. Assume you have a database containing blog posts. Those blog posts have several properties, such as a title, content, or creation date. Additionally, you store the number of views of each one, but you don’t want the end user to see it.

You could take the standard approach as follows:
And then call this endpoint:

The nb_views property is in the output. However, we don’t want this. This is exactly what the response_model option is for, to specify another model that only outputs the properties we want. First, let’s define another Pydantic model with only the title property:

Then, the only change is to add the response_model option as a keyword argument for the path decorator:

Now, let’s try to call this endpoint:
The nb_views property is no longer there! Thanks to the response_model option, FastAPI automatically converted our Post instance into a PublicPost instance before serializing it. Now our private data is safe!

The good thing is that this option is also considered by the interactive documentation, which will show the correct output schema to the end user, as you can see in Figure 3.2:

So far, you’ve looked at options that can help you quickly customize the response generated by FastAPI. Now, we’ll introduce another approach that will open up more possibilities.

### The response parameter

The body and status code are not the only interesting parts of an HTTP response. Sometimes, it might be useful to return some custom headers or set cookies. This can be done dynamically using FastAPI directly within the path operation logic. How so? By injecting the Response object as an argument of the path operation function.

- Setting headers

As usual, this only involves setting the proper type hinting to the argument. The following example shows you how to set a custom header:

The Response object gives you access to a set of properties, including headers. It’s a simple dictionary where the key is the name of the header, and the value is its associated value. Therefore, it’s relatively straightforward to set your own custom header.

Also, notice that you don’t have to return the Response object. You can still return JSON-encodable data, and FastAPI will take care of forming a proper response, including the headers you’ve set. Therefore, the response_model and status_code options we discussed in the Path operation parameters section are still honored.

Let’s view the result:
Our custom header is part of the response.
As we mentioned earlier, the good thing about this approach is that it’s within your path operation logic. That means you can dynamically set headers depending on what’s happening in your business logic.

- Setting cookies

Cookies can also be particularly useful when you want to maintain the user’s state within the browser between each of their visits.

To prompt the browser to save some cookies in your response, you could, of course, build your own Set-Cookie header and set it in the headers dictionary, just as we saw in the preceding command block. However, since this can be quite tricky to do, the Response object exposes a convenient set_cookie method:

Here, we simply set a cookie, named cookie-name, with the value of cookie-value. It’ll be valid for 86,400 seconds before the browser removes it.

Let’s try it:
Here, you can see that we have a nice Set-Cookie header with all of the properties of our cookie.

As you may know, cookies have a lot more options than the ones we have shown here; for instance, path, domain, and HTTP-only. The set_cookie method supports all of them. You can read about the full list of options in the official Starlette documentation (since Response is also borrowed from Starlette) at https://www.starlette.io/responses/#set-cookie.

If you’re not familiar with the Set-Cookie header, we also recommend that you refer to MDN Web Docs, which can be accessed at https://developer.mozilla.org/en-US/docs/Web/ HTTP/Headers/Set-Cookie.
Of course, if you need to set several cookies, you can call this method several times.

- Setting the status code dynamically

In the Path operation parameters section, we discussed a way to declaratively set the status code of the response. The drawback to this approach is that it’ll always be the same no matter what’s happening inside.

Let’s assume that we have an endpoint that updates an object in the database or creates it if it doesn’t exist. A good approach would be to return a 200 OK status when the object already exists or a 201 Created status when the object has to be created.

To do this, you can simply set the status_code property on the Response object:

First, we check whether the ID in the path exists in the database. If not, we change the status code to 201. Then, we simply assign the post to this ID in the database.

Let’s try with an existing post first:
The post with an ID of 1 already exists, so we get a 200 status. Now, let’s try with a non-existing ID:
We get a 201 status!

Now you have a way to dynamically set the status code in your logic. Bear in mind, though, that they won’t be detected by the automatic documentation. Therefore, they won’t appear as a possible response status code in it.

You might be tempted to use this approach to set error status codes, such as 400 Bad Request or 404 Not Found. In fact, you shouldn’t do that. FastAPI provides a dedicated way to do this: HTTPException.

### Raising HTTP errors

When calling a REST API, quite frequently, you might find that things don’t go very well; you might come across the wrong parameters, invalid payloads, or objects that don’t exist anymore. Errors can happen for a lot of reasons.

That’s why it’s critical to detect them and raise a clear and unambiguous error message to the end user so that they can correct their mistake. In a REST API, there are two very important things that you can use to return an informative message: the status code and the payload.

The status code can give you a precious hint about the nature of the error. Since HTTP protocols provide a wide range of error status codes, your end user might not even need to read the payload to understand what’s wrong.

Of course, it’s always better to provide a clear error message at the same time in order to give further details and add some useful information regarding how the end user can solve the issue.

Error status codes are crucial 
Some APIs choose to always return a 200 status code with the payload containing a property stating whether the request was successful or not, such as {"success": false}. Don’t do that. The RESTful philosophy encourages you to use the HTTP semantics to give meaning to the data. Having to parse the output and look for a property to determine whether the call was successful is a bad design.

To raise an HTTP error in FastAPI, you’ll have to raise a Python exception, HTTPException. This exception class will allow us to set a status code and an error message. It is caught by FastAPI error handlers that take care of forming a proper HTTP response.

In the following example, we’ll raise a 400 Bad Request error if the password and password_ confirm payload properties don’t match:

As you can see here, if the passwords are not equal, we directly raise HTTPException. The first argument is the status code, and the detail keyword argument lets us write an error message.

Let’s examine how it works:
Here, we do get a 400 status code, and our error message has been wrapped nicely in a JSON object with the detail key. This is how FastAPI handles errors by default.

In fact, you are not limited to a simple string for the error message: you can return a dictionary or a list in order to get structured information about the error. For example, take a look at the following code snippet:

And that’s it! You now have the power to raise errors and give meaningful information about them to the end user.

So far, the methods you have seen should cover the majority of cases you’ll encounter during the development of an API. Sometimes, however, you’ll have scenarios where you’ll need to build a complete HTTP response yourself. This is the subject of the next section.

### Building a custom response

Most of the time, you’ll let FastAPI take care of building an HTTP response by simply providing it with some data to serialize. Under the hood, FastAPI uses a subclass of Response called JSONResponse. Quite predictably, this response class takes care of serializing some data to JSON and adding the correct Content-Type header.

However, there are other response classes that cover common cases:
HTMLResponse: This can be used to return an HTML response
PlainTextResponse: This can be used to return raw text
RedirectResponse: This can be used to make a redirection
Customizing the response
StreamingResponse: This can be used to stream a flow of bytes
FileResponse: This can be used to automatically build a proper file response given the path of a file on the local disk

You have two ways of using them: either setting the response_class argument on the path decorator or directly returning a response instance.

- Using the response_class argument

This is the simplest and most straightforward way to return a custom response. Indeed, by doing this, you won’t even have to create a class instance: you’ll just have to return the data as you usually do for standard JSON responses.
This is well suited for HTMLResponse and PlainTextResponse:

By setting the response_class argument on the decorator, you can change the class that will be used by FastAPI to build the response. Then, you can simply return valid data for this kind of response. Notice that the response classes are imported through the fastapi.responses module.

The nice thing about this is that you can combine this option with the ones we saw in the Path operation parameters section. Using the Response parameter that we described in The response parameter section also works perfectly!

For the other response classes, however, you’ll have to build the instance yourself and then return it.

- Making a redirection

As mentioned earlier, RedirectResponse is a class that helps you build an HTTP redirection, which simply is an HTTP response with a Location header pointing to the new URL and a status code in the 3xx range. It simply expects the URL you wish to redirect to as the first argument:

By default, it’ll use the 307 Temporary Redirect status code, but you can change this through the status_code argument:

- Serving a file

Now, let’s examine how FileResponse works. This is useful if you wish to propose some files to download. This response class will automatically take care of opening the file on disk and streaming the bytes along with the proper HTTP headers.

Let’s take a look at how we can use an endpoint to download a picture of a cat. You’ll find this in the code examples repository at https://github.com/PacktPublishing/ Building- Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/ assets/cat.jpg.

We just need to return an instance of FileResponse with the path of the file we want to serve as the first argument:

The pathlib module Python provides a module to help you work with file paths, pathlib. It’s the recommended way to manipulate paths, as it takes care of handling them correctly, depending on the operating system you are running. You can read about the functions of this module in the official documentation at https://docs.python.org/3/library/pathlib.html.

Let’s examine what the HTTP response looks like:
As you can see, we have the right Content-Length and Content-Type headers for our image. The response even sets the Etag and Last-Modified headers so that the browser can properly cache the resource. HTTPie doesn’t show the binary data in the body; however, if you open the endpoint in your browser, you’ll see the cat appear!

- Custom responses

Finally, if you really have a case that’s not covered by the provided classes, you always have the option to use the Response class to build exactly what you need. With this class, you can set everything, including the body content and the headers.

The following example shows you how to return an XML response:
You can view the complete list of arguments in the Starlette documentation at https://www. starlette.io/responses/#response.

Path operation parameters and response parameters won’t have any effect Bear in mind that when you directly return a Response class (or one of its subclasses), the parameters you set on the decorator or the operations you make on the injected Response object won’t have any effect. They are completely overridden by the Response object you return. If you need to customize the status code or the headers, then use the status_code and headers arguments when instantiating your class.

Well done! Now you have all the knowledge required to create the response you need for your REST API. You’ve learned that FastAPI comes with sensible defaults that can help you create proper JSON responses in no time. At the same time, it also gives you access to more advanced objects and options to allow you to make custom responses.

So far, all of the examples we’ve looked at have been quite short and simple. However, when you’re developing a real application, you’ll probably have dozens of endpoints and models. In the final section of this chapter, we’ll examine how to organize such projects to make them modular and easier to maintain.

## Structuring a bigger project with multiple routers

When building a real-world web application, you’re likely to have a lot of code and logic: data models, API endpoints, and services. Of course, all of those can’t live in a single file; we have to structure the project so that it’s easy to maintain and evolve.

FastAPI supports the concept of routers. They are “sub-parts” of your API and are usually dedicated to a single type of object, such as users or posts, which are defined in their own files. You can then include them in your main FastAPI app so that it can route it accordingly.

In this section, we’ll explore how to use routers and how you can structure a FastAPI project. While this structure is one way to do it and works quite well, it’s not a golden rule and can be adapted to your own needs.

In the code examples repository, there is a folder named chapter03_project, which contains a sample project with this structure: https://github.com/PacktPublishing/Building- Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/ chapter03_project

Here is the project structure:
Here, you can see that we chose to have packages that contain Pydantic models on one side and routers on the other side. At the root of the project, we have a file named app.py, which will expose the main FastAPI application. The db.py file defines a dummy database for the sake of the example.

The __init__.py files are there to properly define our directories as Python packages. You can read more details about this in Chapter 2, Python Programming Specificities, in the Packages, modules, and imports section.

First, let’s examine what a FastAPI router looks like:
As you can see here, instead of instantiating the FastAPI class, you instantiate the APIRouter class. Then, you can use it exactly the same way to decorate your path operation functions.

Also, notice that we import the Pydantic models from the relevant module in the schemas package.

We won’t go into detail about the logic of the endpoints, but we invite you to read about it. It uses all the FastAPI features that we’ve explored so far.

Now, let’s take a look at how to import this router and include it within a FastAPI application:
As usual, we instantiate the FastAPI class. Then, we use the include_router method to add our sub-router. You can see that we simply imported the router from its relevant module and used it as the first argument of include_router. Notice that we used the as syntax while importing. Since both users and posts routers are named the same inside their module, this syntax allows us to alias their name and, thus, avoid name collision.

Additionally, you can see that we set the prefix keyword argument. This allows us to prefix the path of all the endpoints of this router. This way, you don’t have to hardcode it into the router logic and can easily change it for the whole router. It can also be used to provide versioned paths of your API, such as /v1.

Finally, the tags argument helps you to group endpoints in the interactive documentation for better readability. By doing this, the posts and users endpoints will be clearly separated in the documentation.

And that’s all you need to do! You can run this whole application, as usual, with Uvicorn:
If you open the interactive documentation at http://localhost:8000/docs, you’ll see that all the routes are there, grouped by the tags we specified when including the router:

Once again, you can see that FastAPI is both powerful and very lightweight to use. The good thing about routers is that you can even nest them and include sub-routers in routers that include other routers themselves. Therefore, you can have a quite complex routing hierarchy with very low effort.
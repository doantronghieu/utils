HTTP is a technique for sending and receiving data from a server. The principles of request and response are core to this protocol. When developing an API, the goal is to process the incoming request and build a response for the client. The client must initiate a request to get data from the server. In some contexts, this may not be convenient. WebSocket is a new protocol that allows real-time data exchange between a client and a server in both directions.

In this chapter, covering:
Understanding principles of two-way communication with WebSockets
Creating WebSocket with FastAPI
Handling multiple WebSocket connections and broadcasting messages

# Understanding principles of two-way communication with WebSockets

You have probably noticed that the name WebSockets is a direct reference to the traditional concept of sockets in Unix systems. While technically unrelated, they achieve the same goal: to open a communication channel between two applications. As we said in the introduction, HTTP works only on a request-response principle, which makes the implementation of applications that need real-time communication between the client and the server difficult and inefficient.

WebSockets open full-duplex communication channels for sending messages in both directions simultaneously. Servers can send messages to clients without waiting for client requests.

WebSockets designed to work with HTTP. Connection initiated using HTTP request and upgraded to WebSocket tunnel. Compatible with ports 80 and 443, easy to add to existing web servers.

WebSockets share similarity with HTTP: URIs. Identified through classic URIs, with host, path, and query parameters. Two schemes: ws for insecure connections and wss for SSL-/TLS-encrypted connections.

This protocol is well supported in browsers now, opening a connection with a server involves just a few lines of JavaScript.

Handling WebSocket communication in FastAPI differs from traditional HTTP requests due to real-time two-way communication. FastAPI's asynchronous WebSocket implementation facilitates navigating this difference effectively.

# Creating WebSocket FastAPI

Thanks to Starlette, FastAPI has built-in support for WebSockets. Defining a WebSocket endpoint is quick and easy. Starting simple with a WebSocket that echoes messages back.

In the following example, implementation of a simple case is shown.

The code is understandable, focus on important parts differing from classic HTTP endpoints.

FastAPI provides a special websocket decorator to create a WebSocket endpoint. It takes the path at which it’ll be available as an argument. Other arguments like status code or response model are not available.

Then, in the path operation function, inject a WebSocket object with all the methods to work with the WebSocket.

The first method called in the implementation is accept. This method should be called first to inform the client of agreement to open the tunnel.

After starting an infinite loop, the main difference with an HTTP endpoint is that a communication channel remains open until either the client or server decides to close it. During this time, they can exchange multiple messages, requiring the infinite loop to stay open and repeat the logic until the tunnel is closed.

Inside the loop, first call to receive_text method returns data sent by client in plain text format. It's important to understand this method will block until data is received from client. We won't proceed with rest of logic until then.

The importance of asynchronous input/output is highlighted in Chapter 2, Python Programming Specificities. Creating an infinite loop for incoming data could block the server process in a traditional blocking paradigm. With the event loop, the process can respond to other client requests while waiting for this one.

When data is received, return text data and proceed with the next line. Send back the message to the client using the send_text method. Go back to the beginning of the loop to wait for another message.

The whole loop is wrapped inside a try...except statement to handle client disconnection. The server will be blocked at the receive_text line, waiting for client data. If the client disconnects, the tunnel will be closed and the receive_text call will fail with a WebSocketDisconnect exception. Catch it to break the loop and finish the function.

Run the FastAPI application with the Uvicorn server using this command.

Our client is a simple HTML page with JavaScript code for WebSocket interaction. We will review the code after the demonstration. To run it, serve it with the built-in Python server.

Starting several terminals on Linux and macOS is easy by creating a new window or tab. On Windows and WSL, multiple tabs are possible using the Windows terminal application. Click on the Ubuntu shortcut in the Start menu to open another terminal.

This will serve HTML page on port 9000 of local machine. Open http:// localhost:9000 address, see simple interface like shown here:

You have a simple input form to send messages to the server via WebSocket. Messages appear in green in the list. The server echoes back messages in yellow.

Open Network tab in developer tools of browser to see what's happening. Reload page to force WebSocket to reconnect. You will see a row for WebSocket connection. Click on it to see Messages tab with all messages passing through WebSocket. View interface in Figure 8.2.

In the following example, JavaScript code is used to open WebSocket connection and send/receive messages.

Modern browsers have a simple API for WebSockets. Instantiate a new WebSocket object with the URL of your endpoint and add event listeners for open and message. Use the send method to send data to the server. More details are available in the MDN documentation.

## Handling concurrency

In previous example, assumed client always sending message first: wait for message before sending back. Client takes initiative in conversation.

In usual scenarios, the server can have data to send to the client without being at the initiative. In a chat application, another user can typically send one or several messages that we want to forward to the first user immediately. The blocking call to receive_text shown in the previous example is a problem: while waiting, the server could have messages to forward to the client.

To solve this, rely on advanced tools of the asyncio module. It provides functions to schedule coroutines concurrently and wait until one is complete. Have a coroutine for client messages and another for sending data. The first fulfilled one wins, allowing for another loop iteration.

To clarify, another example will be built. The server will echo the client's message and send the current time regularly. Implementation can be seen in the code snippet below:

Define two coroutines: echo_message waits for text messages from the client and sends them back, while send_time waits for 10 seconds before sending the current time to the client. Both expect a WebSocket instance in the argument.

The interesting part is under the infinite loop: call two functions wrapped by create_task function of asyncio. This transforms coroutine into task object. Task manages execution of coroutine, giving full control over its execution - retrieve result or cancel it.

Task objects are needed for asyncio.wait. This function is great for running tasks concurrently. It requires a set of tasks as the first argument. By default, it blocks until all tasks are done. We can control this with the return_when argument, setting it to FIRST_COMPLETED. This means our server will launch coroutines concurrently. One will wait for a client message, the other will wait for 10 seconds. If the client sends a message before 10 seconds, it will be sent back. Otherwise, the send_time coroutine will send the current time.

At that point, asyncio.wait will return two sets: done contains completed tasks, while pending contains tasks not yet completed.

We need to go back to the start of the loop to begin again. First, cancel all tasks that have not been completed to prevent them from piling up at each iteration. Iterate over the pending set to cancel those tasks.

Finally, make an iteration over the done tasks and call the result method on them. This method returns the result of the coroutine but also re-raises an exception that could have been raised inside. This is useful for handling the disconnection of the client: when waiting for client data, if the tunnel is closed, an exception is raised. The try...except statement can catch it to properly terminate the function.

If try example see server regularly send current time also able echo messages send.

This example demonstrates implementing a process to send data to the client when an event occurs on the server. The next section will cover handling multiple clients sending messages to the server for broadcasting to all clients.

Handle concurrency with asyncio's tools. Everyone can connect to WebSocket endpoints without restriction. Authenticate user before opening connection.

## Using dependencies

WebSocket endpoints can use dependencies like regular endpoints. FastAPI can adapt its behavior to a WebSocket context.

The drawback is the inability to use security dependencies shown in Chapter 7 of FastAPI. Most security dependencies work by injecting the Request object, which only works for HTTP requests. Injecting dependencies in a WebSocket context will result in an error.

Basic dependencies like Query, Header, or Cookie work transparently. Inject two dependencies in the next example:
- Username query parameter for greeting the user on connection.
- Token cookie for comparison with a static value to keep the example simple. A proper user lookup strategy is recommended, as implemented in Chapter 7, Managing Authentication and Security in FastAPI. Raise an error if the cookie lacks the required value.

Let’s see implementation in sample:

Injecting dependencies is no different from standard HTTP endpoints.

Then, dummy authentication logic can be implemented. If it fails, a WebSocketException can be raised, which is the WebSocket equivalent of HTTPException. FastAPI will handle this exception by closing the WebSocket with the specified status code. WebSockets have their own set of status codes, with 1008 being the most generic one for errors. View the complete list on this MDN documentation page: https://developer.mozilla.org/fr/docs/Web/API/ CloseEvent.

If it passes, start classic echo server. Use username value in logic. Send first message to greet user on connection. Try with HTML application, see message first in screenshot.

With the browser WebSocket API, query parameters can be passed into the URL and the browser automatically forwards the cookies. There is no way to pass custom headers. If you rely on headers for authentication, you’ll have to either add one using cookies or implement an authentication message mechanism in the WebSocket logic itself. If you don’t plan to use your WebSocket with a browser, you can still rely on headers since most WebSocket clients support them.

You have a good overview of adding WebSockets to your FastAPI application. WebSockets are useful for real-time communication with multiple users. Next, we'll discuss implementing this pattern reliably.

# Handling multiple WebSocket connections and broadcasting messages

The introduction to this chapter highlighted a common use case for WebSockets - real-time communication among multiple clients, like a chat application. Clients have open WebSocket tunnels with the server, which manages connections and broadcasts messages. When a user sends a message, the server sends it to all other clients through their WebSockets.

A first approach is to keep a list of all WebSocket connections and iterate through them to broadcast messages. However, this method may become problematic in a production environment. Server processes often run multiple workers when deployed, allowing for concurrent request handling. Deployments on multiple servers across different data centers should also be considered.

Hence, nothing guarantees that two clients opening a WebSocket are served by the same process. The simple approach would fail in this configuration as connections are kept in process memory, preventing broadcasting messages to clients served by another process. This problem is schematized in the following diagram.

Message brokers receive messages published by a program and broadcast them to subscribed programs. This follows a publish-subscribe pattern organized into channels based on topic or usage. Examples of message broker software include Apache Kafka, RabbitMQ, and cloud-based options like Amazon MQ, Cloud Pub/Sub, and Service Bus from AWS, GCP, and Microsoft Azure.

Hence, message broker unique in architecture, several server processes connect to publish or subscribe messages. Architecture schematized in diagram.

Set up a simple system using the broadcaster library from Encode and Redis as a message broker.

Redis is a data store for maximum performance, used for temporary data like caches or distributed locks. It supports pub/sub paradigm and can be used as a message broker. Learn more at https://redis.io.

First of all, install the library with the command. The library abstracts away complexities of publishing and subscribing with Redis.

Let’s see details of implementation. In following example, you’ll see instantiation of Broadcaster object.

It only expects a URL to the Redis server. Define a CHANNEL constant as the name of the channel for publishing and subscribing to messages. Use dynamic channel names for real-world applications.

Then, define two functions: subscribe to new messages and send to client, and publish messages received in WebSocket. See functions in following sample.

First of all, notice that defined a Pydantic model, MessageEvent, to help structure the data in a message. Instead of passing raw strings, an object bears both the message and the username.

The first function, receive_message, subscribes to the broadcast channel and waits for messages called event. The data of the message contains serialized JSON that we deserialize to instantiate a MessageEvent object. We use the parse_raw method of the Pydantic model to parse the JSON string into an object in one operation.

Then, check if the message username is different from the current username. All users are subscribed to the channel and will receive their own messages, so discard based on username to avoid this. In a real-world application, rely on a unique user ID instead of a username.

Finally, send message through WebSocket with send_json method for automatic serialization of dictionary.

The second function, send_message, publishes a message to the broker by waiting for new data in the socket, structuring it into a MessageEvent object, and then publishing it.

That’s about it for the broadcaster part. WebSocket implementation is similar to previous sections. Sample provided.

Finally, open connection with broker when starting application and close when exiting.

Be sure Redis container is running before starting Uvicorn server. Command needed:

We provided a simple HTML client in the examples. To run it, serve it with the built-in Python server.

You can access through http://localhost:9000. Open it twice in your browser, in two different windows, to see if broadcasting is working. Input a username in the first window and click on Connect. Do the same in the second window with a different username. Send messages and see them broadcast to the other client.

That was a quick overview of implementing broadcasting systems with message brokers. Only basics covered, more complex tasks possible with these technologies. FastAPI provides access to powerful building bricks without limiting to specific technologies or patterns, easy to include new libraries for expanding possibilities.


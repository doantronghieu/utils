recording Ok thì bằng cách là giảm được cái số lượng thư viện ở bên ngoài mà các bạn download về thì nó sẽ đảm bảo cho cái chương trình của bạn nó nó an toàn hơn nó an toàn hơn so với việc là bạn phải Download Quá nhiều thứ từ bên ngoài Ví dụ như này giả sử bây giờ các bạn Viết note js note js thì các bạn sẽ quản lý phiên bản bằng npm chuyện có thể xảy ra là một ai đó chàm một cái đoạn code xấu ở trong cái package npm mà các bạn download về có thể là chủ của cái thư viện đấy ho cũng có thể là một t n nào đó hack được cái tài khoản của chủ thư viện đấy và quyết định chỉnh sửa những cái package npm đấy để chè một đoạn code có hại theo chương chỉ của bạn cái đoạn code đấy có thể là một cái binary nào đó mà có thể đọc hết được code trong cái dự án mà đã npm install cái package đấy hoặc là cái đoạn code đấy có thể là khiến cho tạo ra một cái backd để mà cái trang web của bạn khi mà sử dụng cái package đấy có thể bị dính lỗi SQL injection đó một trong những cái đấy Thế thì khi mà bạn phụ thuộc vào một cái thư viện bên ngoài tức là điều đấy cũng nghĩa là bạn sẽ bị phụ thuộc vào cái mức độ an toàn của thư viện bên ngoài đấy nếu thư viện bên ngoài đấy có vulnerability có lỗ hổng bảo mật thì bạn cũng sẽ bị ảnh hưởng bởi cái vulnerability đấy hoặc là một cách đơn giản hơn thì có thể là bên đấy người ta không cho phép bạn Download cái package đấy về nữa Ví dụ như npm B tạ khoảng của bạn npm Block địa chỉ ip của công ty của bạn bởi vì các bạn Download quá nhiều từ npm thì lúc đấy bạn sẽ không thể Build được cái d của mình nữa thì bằng cách là giảm thiểu được cái số lượng dependency mà các bạn phải dùng trong dự án của mình thì các bạn bất phụ thuộc bên ngoài hơn các bạn bất phụ thuộc vào cái cái sự an toàn cái sự bảo bật của cái thư viện bên ngoài hơn Nói chung là đối với mình thì cái việc là cả ít dependency sang bên ngoài hơn thì làm tốt hơn đấy nhưng mà trong những trường hợp thì rõ ràng sẽ cần phải có các sử dụng các thư việu từ bên ngoài Ví dụ như khi mà các bạn Download một cái khi mà các bạn làm một dự án react thì chắc bạn chắc chắn là các bạn sẽ cần Download react về khi mà các bạn làm một dự án spring boot thì rõ ràng các bạn phải Download spring boot về khi mà các bạn làm một cái dự án với cả Python khi mà bạn sử dụng pandas rõ ràng các bạn phải download pandas về bạn down coda về những cái đấy không thể tránh được sẽ có những cái không thể tránh được Nhưng mà nếu mà nó cung cấp được những cái giải pháp đấy và mình có thể sử dụng được các giải pháp mà có sẵn ở trong cái thư viện chuẩn thì nó sẽ an toàn hơn hy vọng là như thế cũng có những cái trường hợp mà thư viện chuẩn nó cũng có thể sinh ra Vân ability Nói chung thì mình hay bảo về các bạn của mình khi mà Làm lập trình thì là cái Khi mà mình đi làm ngành lập trình như thế này thì sự hoang tưởng kiể paranoid nó là một đức tính tốt ở trong ngành lập trình Bởi vì các bạn phải C phải đánh giá là ok dùng giải pháp này thì sẽ có cái lợi gì có cái hại gì nếu mà mình dùng giải pháp này Nhớ mà người kia nó không cho cung cấp giải pháp đấy cho mình thì như thế nào có rất nhiều cái hệ thống internet bây giờ đang phụ thuộc vào những cái cơ chế như là dùng We service ch hạn mình bạn mình có câu đùa là nếu bây giờ mà us us is one mà sập thì 80 ph nền kinh tế thế giới sẽ sập đi cùng với nó đấy cũng là một trong những cái vấn đề mà xảy ra khi bạn thích kế phần mềm à Không có cái solution nào là tuyệt đối cả C chỉ có những cái tradle và mình Hi vọng là cái logic đấy nó sẽ giúp cho công việc của mình an toàn trước ai còn nó an toàn được bao lâu thì mình không biết không biết là đến Conan mình sẽ như thế nào nhưng chúng ta sẽ biết chuyện đấy Sau đó thì bây giờ đã là 2:1 chúng ta đã có 11 bạn thì chúng ta sẽ cùng bắt đầu v dự án bắt đầu đi qua những cái kiến thức của ngày hôm nay nhá share mình sẽ share Screen sang BP Ok thì chủ đề chính của buổi ngày hôm nay chúng ta sẽ đi qua là thứ nhất là đi qua cái cơ chế cái test Framework của câu Cái test Framework mà Build in sẵn ở trong cái bộ phát triển phần mệ câu mình sẽ nói qua là việc sử dụng nó như thế nào và mình sử dụng nó như thế nào Cái thứ hai đó là mình sẽ nói qua về những cái thư viện những cái phần mềm mà nó sẽ có thể giúp ích cho bạn khi bạn phát triển cái phần mềm câu ví dụ như là khi bạn viết một chương trình câu thì các bạn sẽ cần phải có liên ting các bạn phải kiểm tra là code của bạn nó có hợp chuẩn hay không Hoặc là nếu mà các bạn viết phần mềm câu thì các bạn sẽ có thể sử dụng những cái design pattern như thế nào để giúp cho cái dự án của bạn nó dễ mở rộng hơn trong tương laine Ví dụ như các bạn có một cái nhu cầu test một cái module nào đó các bạn muốn test cái tương tác với database như các bạn không muốn phải dẫn server database ra để test thì các bạn sẽ làm như thế nào Nói chung thì buổi ngày hôm nay sẽ đ cố gắng là đi quan nốt những cái phần còn lại của cái việc mà thích phát triển một dán Go đến buổi kế tiếp chúng ta sẽ bắt đầu đi vào những cái lý thuyết của việc phát triển dự Hàn back end Nói chung thì cái kiến thức từ buổi ngày hôm sau trở đi nó sẽ là kiến thức nó chung chung nó không bị phụ thuộc vào cái ngôn ngữ mà mình sử dụng mình sẽ sử dụng câu để mà mình Lấy những để mà mình code những cái đạn code ví dụ cho cái cho những cái việc mà mình sẽ làm khi mà mình phát triển một giá back với câu với những cái module phía sau nhưng những những kiến thức về sau nó hoàn toàn không còn phụ thuộc chặt vào Go nữa bởi ngày hôm nay sẽ buổi cuối cùng Mà chúng ta nói về Go như là một Ngô nữ đó thì test Nói chung thì code của bạn có câu là nếu mà code của bạn mà không được test thì tức là nó không chạy và có và chúng ta cần phải có test để đảm bảo là ít nhất là khi mà bạn thích cái phần khi mà Bạn viết cái chương trình của bạn ra bạn cần viết test để đảm bảo rằng là test của bạn đáp ứng đủ những cái nhu cầu của cái tính năng mà đang được yêu cầu đang được đặt hàng mà cần phải làm và cái thứ hai đó là trong tương lai thì khi mà có người khác đi vào và chỉnh sửa cái dự án của bạn thì lúc đấy nhờ nếu bạn đã viết test đầy đủ thì bạn sẽ đảm bảo rằng là cái dự án của bạn những cái thay đổi của người khác nó không làm cho cái logic của bạn Nó bị thay đổi bạn vẫn phục vụ đúng những cái logic như là ngày xưa bạn được đặt hàng thì test nó khá là quan trọng nhưng mà lập trình viên thì rõ ràng là không thích viết test bởi vì là lập trình trình viên thì test không phải là cái thứ mà đóng góp vào cái test không phải là cái thứ mà nó đóng góp vào cái chương trình cuối cùng của bạn thế thì cái mục tiêu của mình là mình viết test viết test làm sao cho nó tiện nhất viết test làm sao cho nó không nó tiễn nhất có thể thì cái thì go trong cái bộ phát triển phẩn M Go nó có đóng gói sẵn một cái cơ chế chạy test gọi là Go test mình sẽ Go head test đây như các bạn thấy nó đóng gói sẵn một cái lệnh đng Go test và Go test này cho phép bạn có thể chạy được test ở trong việc viết test Viết trước hay sau khi code không nha Cái này cũng làm câu hỏi hay thì go test nó đóng gái vào trong cái b cái h bộ phát triển chương trình C của bạn như bạn thấy là bạn sẽ chỉ cần phải sử dụng lệnh Go test để nó tự động hóa cái quá trình testing một cái package Go dựa theo cái đường dẫn và bạn chỉ dẫn Ví dụ như bây giờ mà mình ghi là Go test internal database chấm chấm đấy nó sẽ test những cái file nằm ở trong cái package internal database của mình hoặc là mình có thể viết test Go test chmt 3 chấm thì nó sẽ test tất cả những cái thứ có ở trong dự án của mình đấy thì những cái file test ở trong go Nó sẽ được định nghĩa bằng cái đuôi là gạch dưới test Go như thế này ví dụ như bây giờ mình sẽ move song đây nhá mình có Hello và mình có hàm say hello chẳng hạn thì bây giờ mình sẽ gi cái file này ra đây và mình sẽ đặt tên cho nó là Hello test nh thì cái đầu tiên mà bạn có thể để ý đó là khi mà các bạn viết ở trong Visual stud code thì nó sẽ có gợi ý cho bạn như thế này đó là bạn muốn đặt tên package nó là logic hay là logic test trong buổi ngày hôm trước trong buổi đầu tiên chúng ta còn nói ra là package ở trong Go thì một thư mục chỉ có thể có một package và điều đấy là đúng Tuy nhiên thì những cái file test nó lại có thể cái file test khi mà ở trong quá trình view thì nó sẽ không bị bao gồm nó sẽ không bị đưa vào trong quá trình view nó sẽ không bị tính cái package test nó sẽ không bị tính là là làm là một phần của cái dự án của bạn do đó nên bạn có thể có hai lựa chọn lựa chọn thứ nhất là đặt cái tên file test đặt file test của bạn nằm ở trong package gốc mà các bạn muốn test nó cái lựa chọn thứ hai là đặt nó trong cái package S test thì cái sự khác nhau giữa package Go và package stest là gì là nếu mà bạn sử dụng package stest thì bởi vì nó là một cái package k khác nên bạn sẽ không có thể truy cập được đến cái hàm Ví dụ như trong Hello này chẳng hạn mình có một hàm public và một hàm Private Nếu mà bạn sử dụng S test thì tức là bạn đang truy cập bạn đang test từ một cái package bên ngoài và để đấy có nghĩa là bạn sẽ không thể truy cập được vào cái C Hello Private này được nếu mà bạn muốn test những cái gì propic nếu bạn muốn test những cái gì Private thì bạn cần phải khai báo là nó thuộc vào package logic và lúc đấy nó mới có thể để truy cập được và xe Hero này Thế thì cái việc xảy ra đó là chúng ta có cần phải test những cái gì Private hay không Mình sẽ nói là không Mình sẽ nói là không Bởi vì những cái gì Private là những cái những cái Private là những cái thứ mà nằm ở trong dự án của bạn những cái logic mà nó đóng gói đóng gói ẩn ở bên trong những người một khi mà bạn đã Chìa ra public thì tức là bạn phải xác định rằng là sẽ có người sử dụng những cái function đấy sẽ có người sử dụng nếu bạn bạn Chìa ra một cái d public sẽ có người sử dụng cái function đấy kể cả khi bạn viết nó là public để cho nó tiện thi chẳng ạ sẽ có người sử dụng cái function đấy có thể có người sử dụng có thể sẽ có người sử dụng cái function đấy để mà cũng bởi vì họ nghĩa được tiện Cũng có thể là cũng có thể họ nghĩa được tiện kể cả chìa ra một cái function utility một cái function hỗ trợ utility nhọc bé thôi người ta vẫn sẽ có thể sử dụng nó bởi vì người ta cũng nghĩ rằng là lúc đấy Cái function này nó tiện đối với họ và điều đó có nghĩa là bất cứ cái gì và public thì bạn phải test rồi Cái này là không cầ phả phả Ngãi những cái gì Private thì sao những cái Private là những cái mà nó không được sử dụng về bên ngoài và nó được đóm gói nhỏ lại để hỗ trợ trong cái pack ở trong cái nội dung của package đấy Thôi thì mình sẽ cho rằng những cái gì Private những cái gì Private ở trong package thì có thể bị thay đổi bất cứ một lúc nào và không nên được test không nên được test bởi vì điều đấy có nghĩa là sau này bạn muốn cài đặt những cái tối ưu ở trong những cái hàm Private của bạn thì nó sẽ thì mỗi khi bạn cập nhật Cái gì đó Private ch của bạn thì điều đấy cũng nghĩa là bạn cần phải cập nhật lại test của bạn tương ứng nó sẽ rất là chậm những cái gì public những cái gì public là Future và Future thì cần phải được test nhưng mà những cái gì Private thì là hệ thống bên trong hệ thống bên trong có thể bị thay đổi bất kỳ bất ngờ miễn là cái giao diện cái hợp đồng đối với bên ngoài nó không bị thay đổi thì bên trong Private nó có thể đ Mở cư kiểu gì cũng được do đó nên là mình sẽ cho rằng là những cái gì Private thì không cần phải test bạn phải test bạn phả cố gng test tất cả những gì public Nhưng những gì Private không cần phải test do đó nên là mình sẽ thường hay sử dụng là logic dưới test thì điều đấy đảm bảo là mình sẽ không truy cập tới những cái gì Private và một khi mình xác định là mình không truy cập t những gì Private thì có nghĩa là mình sẽ chỉ test dựa trên cái hiểu biết của mình với một cái package khi nhìn vào nó từ bên ngoài cái này chúng ta có cụng từ cho nó là Black box testing Black box testing có nghĩa là test từ bên ngoà mà không sử dụng bất cứ một cái hiểu biết gì đối với cả kiến thức ở bên trong của một cái hệ thống logic nó đối ngược với cả wbox testing wbox testing có nghĩa là bạn biết ở bên trong nó như thế nào thì cả hai cái nó chỉ là khác sự khác biệt nó đem ra lại những sự khác biệt trong cái quá trình viết test của bạn đó Vừa nãy có bạn Kiều Thanh Nam B hỏi là việc viết test sẽ được viết trước ha viết sau khi code V Anh thì cái này chúng ta có một cụm từ khác gọi là test driven development Anh cết tắt là tdd thì đây là một cái một cái hình thức viết lập trình khi mà đầu tiên là bạn sẽ bắt đầu việc là viết một cái interface Viết những cái viết những cái tuyên bố ở mức độ nhỏ nhất có thể bạn chỉ viết mỗi cái khung xương của chương trình của bạn thôi nếu mà ví dụ mình có x Hello chẳng hạn mình sẽ chỉ có Return một cái gì đó ở đây đấy Đây là cái mức độ tối thiểu đ mình khai báo rằ là có một cái hàm tên là say hello và sau đó mình sẽ viết test cho cái hàm C Hello này trước khi mà mình viết cái implementation cái cài đặt bên trong của C Hello thì điều đấy giúp cho mình là đảm bảo đầu tiên giúp điều đấy giúp cho mình là viết test nó không bị phụ thuộc mình sẽ không bị điểm m mình sẽ không bị viết test để mà C mình sẽ không bị bias khi mà viết test và nó giúp cho mình viết test không phải là mình đang viết test một cách ốn éo để khiến cho cái chương trình của mình nó pass test điều đấy là không nên thì thay về đó mình chỉ biết cái mức độ tối thiểu để khai báo là có c Hello ở đây mình viết tất cả nh cái trường hợp test thỏa mãn theo cái yêu cầu đặt hàng ở bên ngoài rồi sau đó mình mới cài đặt C Hello để làm sao nó đạt được cái điều kiện Mình muốn thế thì bây giờ chúng ta có Ok thì bây giờ chúng ta sẽ áp dụng test driven development ở đây thì mình có x Hello Và mình muốn thì cái đơn đặt hàng của mình đã ra là C Hello thì mình sẽ cần phải là à output Hello cộng với cả cái things mà mình đang muốn nói lời chào Đấy Bây giờ mình sẽ viết một cái hàm gọi là test say hello như các bạn thấy thì một cái hàm test ở trong cái file test của Go nó sẽ có cái cố Pháp như thế này nó bắt đầu bằng test sau đó là một cái tên gì đó để mà Bạn định nghĩa là cái test này test t cái gì và cuối cùng là cái hàm này nó sẽ phải nhận một cái input input của nó sẽ là một cái đối tượng testing CHT testing CHT này nó sẽ quản lý khá là nhiều thứ Ví dụ như bây giờ trong cái testing CHT này bạn có thể sử dụng một cái hàm ví dụ như là fail fail thì cái hàm này sẽ đánh giấu là cái test này đã fail nhưng mà vẫn cho phép bạn cho phép bạn tiếp tục thực hiện cái execution của test này ví dụ như bạn có TH sử dụng log cái này cho phép bạn log trong quá trình test để bạn có thể biết được chuyện gì đang xảy ra trong cái test của mình hoặc là các bạn có thể sử dụng những cái test những cái hàm khác ví dụ như là bạn có thể đánh dấu heer đánh dấu cái hàm này thật ra chỉ là một cái hàm hỗ trợ trong quá trình test mà thôi hoặc là ví dụ như parallel parallel là gì parallel đánh dấu rằng cái test này có thể chạy song song với tất cả những cái test khác ở trong package thì nó giúp cho bạn tận dụng được nhiều CPU Core hơn khi mà chạy test và giúp cho cái việc và test nó nhanh hơn thay vì là chạy từng cái test một theo thứ tự từ trên xuống dưới thì parallel cho phép bạn là chạy test song song với nhau Nó sẽ tạo ra nhiều cái lợi thế lợi thế thứ nhất đó là đảm bảo rằng là test của bạn sẽ không bị bias ở cái chỗ là bạn kiểm tra được cái trường hợp là test của bạn đang chạy Xong song chứ không phải là test của bạn đang chạy tuần tự thì nó sẽ giúp bạn đảm bảo ví dụ bạn muốn đảm bảo tránh được là Race condition chẳng hạn bạn đảm bảo là cái hệ là cái logic của bạn không ảnh hưởng với r condition thể đặt nó parallel để cho nhiều test chạy song song với nhau hoặc là bạn chỉ đơn giản muốn sử dụng nhiều CPU Core hơn thì go Nó sẽ test những cái file nó sẽ chạy những cái test ở trong những package khác nhau song song với nhau còn trong cùng một package thì nếu mà không đánh dấu parallel thì chúng nó sẽ chạy Tần tự Nếu bạn đánh dấu parallel thì chúng nó sẽ chạy song song với nhau đấy thì việc đánh dấu parallel nó chỉ giúp bạn tăng tận dụng được nhiều tài nguyên CPU co hơn vào việc là đánh dấu là cái test này có thể chạy song song với những test khác đấy Thì bây giờ mình sẽ theo cái cái thói quen của mình thì mình sẽ đánh dấu test này là parallel để mình có thể chạy song song nhá Đấy Và bây giờ thì sẽ có thử một số cái thứ ví dụ như là mình muốn là output bằng với à logic chc Hello đó và Mình giờ mình muốn nó x Hello với cả World chẳng hạn đấy Thì bây giờ mình sẽ cần phải kiểm tra bây giờ mình có cái output của việc x Hello này rồi thì If output khác Hello không đấy thì T ch [âm nhạc] f như các bạn thấy là cái test này nó rất đơn giản kiểm tra xem là x Hello có hiện tại đang output the Hello world không Nếu có thì anh s f và b mình sẽ viết thêm một test nữa đó là logic C Hero và cho một cái MT vào đây và nếu mà output If output khác Hello ch [âm nhạc] fil để ý nhá Hello world thì sẽ có một cách giữa Hello và World Hello thì chỉ có Hello không thôi và Không d cách đó thì bây giờ mình đã có file test này rồi mình muốn test nó thì mình sẽ làm như thế nào mình sẽ sử dụng lệnh Go test và mình sẽ chỉ dẫn tới các package mà mình muốn test vụ là internal logic đó mình có thể ở đây thì nó sẽ nhận vào một cái patter patter này sẽ cho phép bạn Lọc ra những cái file nào bạn muốn test và Nhữ hay là bạn không muốn test không muốn tham gia vào cái quá trình mà Bạn test thì ví dụ nếu bây giờ mình chạy test Hello test Go này đó nó sẽ nó sẽ fail vào đây fail bởi vì là cái hàm Hello của mình nó chưa được cài đặt đó nếu bây giờ mà mình muốn test tất cả Nếu mà bây giờ mình muốn chạy tất cả các file test ở trong cái chương trình này thì mình sẽ sử dụng cái ký tự sau ở đây nó sẽ tự động check qua tất cả những cái file test và nó sẽ tự chạy qua tất cả những file có đuôi là se test.com ở trong cái package logic này các bạn có thể để ý nhá thì ở đây chúng ta có tốc độ của cái lần chạy đầu tiên này là 0,42 tốt độ của lần chạy đ hai này là tương này đấy thì go có một cái bộ test của Go của có một tính năng nữa đó là nó sẽ catch cái kết quả của lần chạy của bạn Nếu mà package của bạn không có thay đổi gì giữa những cái lần chạy thì nó sẽ không Chạy lại Cái test đấy nó sẽ nếu mà cả nếu mà test hoặc là cái package được test và không có thay đổi gì thì nó sẽ không Chạy lại Cái test đấy điều đấy có nghĩa là nếu mà lần trước mà cái test của bạn đã thành công rồi và không có một cái thay đổi gì diễn ra từ lúc đấy đến giờ thì go test sẽ không cần phải thực hiện cái việc chạy cái test đấy nữa trên trình các bạn autop pass hoặ auto fail dữa trên kết quả của lần test cuối cùng Đây là một cơ chế để mà giúp tiết kiện thời gian khi mà các bạn chạy test nhiều lần nó sẽ chỉ test những cái gì mà đã bị thay đổi thự lực cuối cùng chạy test thôi thì cái thông tin cái thông tin tas đấy nó sẽ nằm ở một cái vị trí nó gọi là Go cat Go cch nằm ở trong cái thư mục Go của cái đây để mà bây giờ chúng ta xem cái thư mục Go Ừ LS trong thư mục trong cái chương thư mục home của mình thì mình nhớ là sẽ có một cái thư mục gọi là Go cch Go catch Nó là cái nơi mà cái chương trình go Nó catch l kết quả chạy nó không qu đây lại đây là cái thông tin cái thông tin này là thông tin v c v Go thôi không cần mình không cần phải biết cái đấy V mình không cần sử dụng cái đấy trong đây đây đây là C cch thì câu catch này sẽ là cái nơi mà cái chương trình test của bạn catch lại kết quả Build test là catch lại kết quả test giữa những cái lần chạ kế tiếp để mà biết rằng là cái test nào cần phải trảy lại test nào không cần phải trảy lại Ok thì bây giờ bây giờ chúng ta đã có cái Hello test ở đây mình có hai test case test case thứ nhất là Hello world test cas thứ hai là Hello đ thì bây giờ mình sẽ cài đặt Hello và đây thì đầu tiên mình phải t kiểm tra If things bằng empty đó Return Hello Còn nếu không thì sẽ Return là Hello cộng things bây giờ chúng ta chạy lại cái test này ok đấy vậy test này là pass mà các bạn bạn thấy là cái thời gian chạy là 0,41 giây Tức là nó đã phải Build lại cái này bây giờ mình chạy một lần nữa kết thúc giất nhnh bởi vì nó không phải Build lại cái thông tin này nữa đấy nếu bây giờ các bạn muốn hỏi là bây giờ mình muốn test hết tất cả những cái thứ ở trong dự án của mình như nào thì chúng ta có thể sử dụng cái ba tầm ba chấm để lấy tất cả các file Ví dụ như này maral package chúng ta sẽ ta chấm như thế này đó nó sẽ test tất cả những cái thứ ở trong chương trình của mình nó test tất cả cản thứ trong chương trình của mình thì ở đây thì nó đang báo lỗi với mình là cái file cái hàm main.go này cái hàm main.go này hiện tại đây là nó đang bị sai cố Pháp do đó nên là nó thất bại trong việc Build cái hàm m. go do đó nên là nó sẽ không test cái package này Cản cái package internal logic của mình thì vẫn Build thành công bởi vì nó không có cú pháp nó không có lỗi cú pháp gì trong này cả do đó nên là nó vẫn pass nó vẫn chạy test Thì đấy là ở cái mức độ cơ bản nhất đấy là mức độ cơ bản nhất bạn viết cái function bạn viết một cái function và bạn viết test cho nó bạn sử dụng cái kết quả của function đấy như bình thường và sau đó thì bạn test nó ở đây hoàn toàn thể viết test tr một chương trình như thế này bạn sẽ không cần phải có cái gì nó quá m mè Đây là mức độ tối thiểu Bạn test Đây là mức độ tối thiểu bạn cần test rồi nhưng mà đôi khi nó sẽ xảy ra một số vấn đề Ví dụ như này cái vấn đề đầu tiên mình có thể nghĩ tới đó là giả sử như mình có một cái giá trị gì đó và mình muốn khởi tạo cái giá trị đấy Lúc mà mình bắt đầu chương trình ví dụ như bây giờ mình có một cái giá trị là 3 curent time đó Đây là một giá trị kiểu time và giả sử mình muốn là khởi tạo cái current time này bằng một cái giá trị gì đó Mình muốn kiểm tra Mình có một vài logic muốn kiểm tra à If environment [âm nhạc] variable time not use now otherwise use. [âm nhạc] go. đó có nghĩa là bây giờ mình có current time ở đây curent time ở đây thì mình muốn nó có một mình muốn điều khiển cái giá trị của nó nếu mà mình không tìm thấy được cái biến môi trường time ở trong môi trường mình chạy Go test thì mình sẽ sử dụng thời điểm hiện tại còn nếu mình tìm thấy thì mình sẽ sử dụng cái giá trị đấy để mà mình pass nó ra một cái giá trị time và nếu mà pass thất bạn thì mình sẽ kết thúc luôn bộ test và mình không làm gì cả thì đây là một cái việc mà có thể xảy ra là bạn sẽ setup một số cái giá trị trước khi bạn đã bắt đầu chạy test thì lúc này ở trong cái function trong cái package test của bạn sẽ có một cái function đặc biệt Gọi B test main đấy test main ở đây là cái nơi mà bạn sẽ chạy cái Đây là cái hàm đầu tiên mà sẽ chạy ở trong một cái package test đó thì giả dụ ở đây mình sẽ thực hiện cái quá trình kiểm tra là time and bar B OS ch environ Ừ environment n sẽ trả về một danh sách Nhữ cái get đó mình sẽ lấy time If time en bằng MT có nghĩa là không có thì current time sẽ bằng 5.5 Còn nếu không thì cur time sẽ bằng c ch pass time env value string nó sẽ pass cái à Không nó sẽ đầu tiên phải có một cái layout ở đây time chấm à rf 339 và đy nó sẽ nhận V một cái format Bạn nhận được string là cần phải pass nó sẽ pass nó sẽ trả lại hai giá trị là current time và một cái lỗi nếu mà có thì lỗi này mình sẽ cần khá báo trên đấy Thì bây giờ mình cần phải kiểm tra If new đấy thì m mình sẽ kết thúc luôn bộ test ở [âm nhạc] đây đó C nếu không thì curent là nó sẽ được thành công mình sẽ có giá trị current time Thì bây giờ mình sẽ m ch run m run sẽ giúp mình là run cái bộ test nếu mà nó trả về một cái lỗi một cái exist code trong quá trình run test thì nó sẽ trả về code đấy cho mình đấy thì có nghĩa là ở trong này test m đấy s cái n mình khai t khơ mình khởi tạo các giá trị ở trong cái môi trường test của mình trước khi mình thực hiện cái việc test những cái hàm khác thì bây giờ mình thực hiện vi test em khác ở đây thì mình sẽ viết một cái function test Mới test curent testing ch đó và ở đây thì mình sẽ chỉ làm một công Việ cất thôi t. blog test này không thể fail được test này sẽ chạy bình thường thôi Thì đó Thì bây giờ mình sẽ chạy Go test internal logic s.com đấy thì trong cái lần chạy đầu tiên nó thành công nhưng mà mình sẽ muốn là phải in ra được cái giá trị đấy ra mình muốn nhìn cái giá trị in ra đấy thì nó sẽ in ra cái giá trị Vào cái thời điểm mình đang chạy thời điểm hiện chạy là 11:33 ph 8 giây chiều tức là đúng với thời điểm hiện tại bây giờ mình sẽ lấy cái giá trị này ra mình sẽ lấy cái giá trị này ra và mình muốn pass lại cái gi mình sẽ muốn update lại cái giá trị này sao cho nó hiển thị bởi à hiển thị bởi chương trình bị khác đi bây giờ mình sẽ dùng cái biến môi trường là time như thế này mình sẽ đặt nó năm 2021 và mình chạy Go test in logic t c phải thêm một cái v nữa để cho nó hiển thị ra được cái output ừ sao nó output nhiều thế này nhỉ Có vẻ như là nó đang output cả những cái thứ ở trong vender Nếu mình không nhầm T sao Go test V internal logic package [âm nhạc] hello.com Có vẻ như là nó đã lấy kết quả catch bởi vì nó lấy kết quả cch n nó không output lại như vậy Giờ mình sẽ chạy Go test và với option là no catch option là no [âm nhạc] Ừm Go test Go clean test catch mình sẽ cần phải sử dụng lệnh là Go clean test catch để mà xóa cái bộ couch của mình đi Sa chạy cái Go file in document [âm nhạc] go go test Ừ interesting có vẻ mình chưa thể output ra được cái current time như này nhưng mà về cơ bản thì cái lý thuyết của nó sẽ là mình có thể sử dụng được cái hàm test main ở đây HM test ở đây để cho phé mình là setup những cái thứ mình cần trước khi mà mình chạy những cái bộ test của mình thì ví dụ như là mình có thể đưa ra những ví dụ như là mình có một cái server database mình muốn test một cái logic tươ TP với cái database mysql và mình cần phải dùng một cái thư viện ở bên ngoài để mà mình điều khiển cái container server myq bên ngoài đấy để setup để đảm bảo cái server đấy chạy và server đấy hiện tại là đang listen port 3306 trước khi mà cái test logic database của mình bắt đầu thì mình sẽ sử dụng cái hàm test mday để mình setup cái server database đấy trước khi mình dùng m. run để mình chạy những cái test còn lại như say hello say cent time Hoặc ví dụ khác như là mình có một số cái giá trị như như current time ở đây muốn lấy những cái giá trị ra từ phía môi trường hoặc là lấy ra từ một cái file config của nó bạn có thể sử dụng test main để mình bọc những cái file đấy và setup nó ở trong biến môi trường trước khi mà bạn bắt đầu thực hiện test đấy thì chúng ta Vừ đi qua là việc viết những cái hàm test sử dụng test main để mà set up những cái môi trường trước khi bạn thực hiện test và bạn đánh dấu là một cái test fail hoặc là bạn log out cái thông tin như thế nào ngoài cái việc sử dụng test fail ra thì bạn có thể sử dụng một cái khá là Panic bạn có thể sử dụng Panic cũng được ví dụ như là incorrect output rồi hay sử dụng test fil mình thì sẽ có cụ pháp nào thì mình có cố pháp test fail ở đấy thì mình sẽ sử dụng nó thì mình nghĩ hợp lý hơn nhưng mà bạn cũng có thể như này cũng được đó Ok thế thì có bạn nào Câ hỏi gì về những cái m này không ạ test database là cái hạm test đó sẽ thực hiện luôn và query luôn và database đúng không Anh chính xác chính xác thì câu chuyện sẽ như này câu chuyện như này à khi bạn viết unit test thì cái định nghĩa của Unit test là bạn viết một cái test thì có thể chia ra nhiều kiểu test khác nhau Bạn có unit test là Phả test một cái module trong chương trình của bạn và bạn cố gắng làm sao bạn chỉ test module đấy thôi và cái module đấy được test và nó không bị nó không bị ảnh hưởng với những cái modu bên ngoài bạn không cần phải set up những cái module bên ngoài bạn giả sử là những cái modu bên ngoài hoạt động đúng 100 thời gian thì bạn chỉ test cái module bạn thôi để là unitest bạn có end to end testing end testing là test từ đầu đến cuối có nghĩa là khi bạn đấy lú bấy bạn sẽ phải tương tác bạn sẽ phải setup là cái service của bạn đang chạy nếu ví dụ Bạn test một cái server http bạn sẽ phải test cái server http đ chính xác hay không Nếu bạn gửi một cái request thì cái request đấy có được pass Chính xác vàở cái cái modu logic của server http không Cái input đấy sau khi đã t chính xác xong rồi thì có được xử lý chính xác bởi cái bởi cái business logic của bạn hay không và sau khi đã xử lý chính xác xong rồi thì cái output mà cái trả về cho bạn nó có chính xác không Thì đấy là end to end testing là test từ đầu đến cuối test tất cả các tương tác của tất cả các modu từ đầu đến cuối bạn còn có integration testing thì integration testing là không chỉ mỗi cái module của bạn thôi không chỉ mỗi cái service của bạn thôi mà lúc này sẽ cần phải đi cùng với những cái thứ khác như là server database như server catch như là các service khác các service khác khi mà đã đúng khi mà đã được dựng lên rồi thì có được test thì có hoạt động chính xác HP có hoạt động à chuẩn chỉ với nhau không thì ok đó câu hỏi này rất hay giả sử mình test Insert và database thì data cho database nó bị thay đổi vậy có ảnh hưởng đến dữ liệu không ạ có chính xác Đấy là một cái vấn đề khi mà bạn unit test cái module database của bạn bởi vì sao Theo định nghĩa thì module database của bạn là bạn phải tương tác với cả một cái database ở phía bên ngoài một cái component bên ngoài nhưng mà bạn vẫn muốn là cái test của bạn đấy nó phải độc lập khỏi những cái module khác assume là cái database của bạn hoạt động chính xác và những cái test database của bạn trong trường hợp tốt nhất đó là cái test này nó không ảnh hưởng đến test kia có thể bị sai M test điều đấy có nghĩa là Nhưng mà điều đấy không nên có nghĩa là những cái test khác của bạn cũng sai và bạn cố gắng làm sao mà cái test của bạn khi mà khi mà nó chạy Xong rồi thì phải trả về cái trạng thái ban đ đầu để cho những cái test khác chạy tiếp để mà cái kết quả sai của một test này nó không ảnh hưởng đến những cái test khác thế thì cái này thì ở trong Ruby on Rail Nó đã giải quyết rồi nhưng mà mang sangle thì cũng có một cái thư viện tương tự như thế nó là cái thư viện gọi là test fixture để trướt mình sẽ mở cho các bạn Go test [âm nhạc] fixture thì go test picture Nó là một cái thứ viện Lấy cảm hứng từ ruby on Rail nó cho phép bạn là định nghĩa cái data ở trong database của bạn mà bạn muốn là cái database đấy là nó phải ở trạng thái đấy trước khi bạn bắt đầu unit test cho database ví dụ như thế này ví dụ như là bạn import cái thư viện này vào và sau đó bạn sẽ tuyên bố là bạn có một cái bảng có tên là comment và ở trong cái Comment này nó sẽ chỉ có một số cái dòng là ID bằng 1 post ID bằng 1 comment có nội dung như thế này author của tên là như thế này nó tạo ra vào thời điểm này id2 nó tạo ra như thế này đó hoặc là đấy thì khi mà bạn có cái file Yam định nghĩa danh sách những cái dòng ở trong cái database của bạn trước khi test bắt đầu thì lúc đấy Bạn có thể sử dụng test picture ở trong test main bạn sẽ mở kết nối tới database sẽ khai B test picture này sẽ sử dụng cái object database này của Go của Go có hiện tại là đang gia tiếp với cả một s postc và nó sử dụng những cái kiến thức nó sẽ sử dụng những cái content ở trong cái thư mục test data test fixture để mà setup database để mà setup database trước mỗi cái test trước khi mà bạn thực hiện chạy test x test y và test Z bạn sẽ phải cần phải họi Gọi cái hàm prepare test database và nó sẽ ở dưới nó sẽ gọi tới cái fixture load như thế này thì fixture trong load này nó sẽ Đạ giúp bạn đảm bảo rằng là nó sẽ xóa hết tất cả content trong database của bạn đi và nó sẽ cắm cái content mà bạn đã cung cấp ở trong file Yam và trong database đều đấy giúp đảm bảo là cái trạng thái của database trước khi bắt đầu test nó sẽ là cái trạng thái mà đã định nghĩa ở đấy và điều đấy sẽ giúp là kết quả những cái lần chạy test của các bạn sẽ độc lập khỏi nhau những lầ chạy test của bạn sẽ độc lập khỏi nhau và kết quả của một test này nó sẽ không ảnh hưởng đến cái output của mọi test khác mình sẽ gửi cho các bạn link của cái thương miện ở trong chat test mà có inbox DB thì có thể xài interface rồi gọi một cái mod service tới dumy data Ừ cái này nó là test của cái logic mà sử dụng thư viện database chứ không phải là sử dụng chứ không phải là cái test link cái query database của bạn ở đây là mình đang nói tới cái test của cái query database có nghĩa là mình muốn kiểm tra xem cái query database của mình có biết đúng hay không và cái này thì bạn không thể làm chắc chắn 100 ph được trừ khi mà Bạn test ở trên một cái server database thật tức là điều này có nghĩa là bạn sẽ cần phải có container postpress chạy sẵn ở nền và bạn Connect từ cái database đấy và bạn gửi cái query SQL của bạn lên cái server post đấy nếu mà cái server sẽ trả về đúng tức là bạn làm đúng test ở những cái phía business logic mà sử dụng database thì rõ ràng là lúc đầu tiên khi bạn code là bạn đã phải dựa trên một cái interface rồi để mà bạn không để mà bạn không phụ thuộc chặt lên cái logic không phụ thuộc chặt lên cái logic database đấy và cái thứ hai đúng như bạn ấy nói là nếu mà có bao gồm database ở đây thì chúng ta sẽ sử dụng một cái m service để mà test test để mà tương tác với cái móc đấy thay vì tương tác lên cái database thật Ok thì thật ra là mình đang định nói mình đang định chuyển cái mục này sang cái mục thứ hai của cái buổi ngày hôm nay đó là những cái thư viện mà bạn có thể muốn sử dụng chung với cả test để giúp cho quá trình test của bạn nó dễ dàng hơn bây giờ chúng ta sẽ nhảy luôn vào mục đấy Nhưng mà trước khi mình nhảy vào mục đấy thì có bạn nào có câu hỏi gì về cái cơ chế viết test của Go không ạ Ok Ok thế thì bây giờ cái đầu tiên mà các bạn có thể thấy đó là chúng ta sẽ quay lại với cái cửa sổ Visual stud code ở đây p cái đầu tiên các bạn có thể thấy ở đây trong cái quá trình test đó là chúng ta đ phải test cái này một cách rất là thủ công ta kiểm tra xem là output này có bằng Hello world không Nếu bằng output này và bằng Nếu không bằng Hello world thì chúng ta sẽ Panic thì quá trình này nó hơi thủ công một chút tức là mỗi lần mà mình kiểm tra ra cái điều kiệ nó sai thì mình sẽ về tuyên bố là kết thúc test nó như vậy thì một cái mà các bạn có thể khi bạn viết nhiều dòng test như này thì các bạn có thể đặt ra câu hỏi đó là ước gì tôi có thể gộp hết tất cả ba dòng này là một dòng để tôi đỡ viết nhiều thì lúc này chúng ta sẽ có những cái thư viện đầu tiên nó sẽ là những cái thư viện assertion ví dụ như là cái thư viện mình đ hay sử dụng đó Cái thứ viện mà mình đang hay sử dụng đó là testing file se assert test file se assert đó mình sẽ save cái này lại save xem nào save mnh mình có vender ở đây X vender đi đỡ phải download vender đó Bây giờ mình sẽ Go Mode ID để download cái ass này về thì cái thư Việ assus này có thể giúp bạn là gộp lại hai cái dòng này là một ví dụ bạn sẽ check là assert ch equal đấy mình sẽ phải truyền vào cái đối tượng testing đầu tiên sau đó mình sẽ truyền vào hai cái đối tượng ví dụ như là output mình sẽ expected là Hell World nhưng mà cái giá trị thực mà mình nhận được sẽ là output đó và thì cái dòng này Ở đây có nghĩa là cái giá trị kỳ vọng Hello world này sẽ giá trị output Còn nếu mà nó không bằng nhau thì lúc đấy tôi sẽ output ra lại incorrect output Đấy đấy là cái đầu tiên mình có thể giúp cho cái quá trình test của mình nó nhỏ gọn hơn là mình dùng cái thư viện assert này thì bây giờ mình sẽ tắt cái nội dung của cái hàm Hello world này đi để nhìn thấy cái ass này hoạt động trong thực tế Go test internal đó thì như các bạn thấy là Asus nó cung cấp cho mình một cái giao diện nó tiện lợi hơn nó Không chỉ là mỗi cái message incorrect output ở đây nó con cho phé mình là so sánh được cái giá trị expected Hello world và cái giá trị thực mà mình nhận được ở trong cái output của cái hàm này đó thì ngoài cái việc kiểm tra equal ra thì như các bạn thấy outch nó sẽ còn có thể hỗ trợ về rất nhiều thứ khác ví dụ như là condition condition cho phép mình là kiểm tra xem là cái cái điều kiện mà mình đang muốn có phải là đúng hay không contain là sẽ sử dụng để kiểm tra xem là một một cái map hoặc là một cái slide có chứa cái dữ liệu mà mình đang muốn kiểm tra hay không kiểm tra directory exist kiểm tra xem là cái thư mục có tồn tại hay không El match thì kiểm tra xem là hai cái slide nó có chứa cùng một cái bộ dữ liệu hay không mặc kệ thứ tự thứ tự th khác nhau nhưng mà nội dung cái nội dung bên trong phải giống nhau là ví dụ như là equal equal ER equal value hoặc là erot kiểm tra xem là một cái có erot này có phải là new hay không Nếu mà erot này không phải nếu erot này new thì nó sẽ trả về lỗi và nếu mà ở đây ass erot thì là ER Tức là kiểm tra s là chắc chắn phải có lỗi đấy Ở đây mình muốn nói thêm một cái nữa là ở đấy có hai hàm equal và equal value thì equal ở đây nó phải đảm bảo là cái giá trị nó phải bằng nhau không chỉ bằng nhau về giá trị mà nó còn phải bằng nhau về cả cái kiểu dữ liệu tức là nếu mà một cái dữ liệu của mình là kiểu dữ lượng int mà cái còn lại là int64 nó sẽ trả lại false nó sẽ báo lỗi vì cái giá trị mà mình muốn nhận về nó phải là một cái giá trị HC kiểu dữ liệu chính xác nó giúp là đạp nó sẽ tránh bạn nếu mà các bạn Có code JavaScript thì bạn sẽ biết cái toán tử bằng bằng và Toán tử b bằng bằng đấy thì cái equal này nó sẽ là cái toán tử ba bằng còn cái asset và equal value thì nó là t tự hai bằng có nghĩa chúng nó sẽ bằng nhau về giá trị và uin 23 sẽ bằng với cả uin 32 Nếu mà chúng nó có giá trị V trọ bằng nhau nhưng mà Bình thường thì mình không muốn sử dụng equ valu như thế này cũng giống như là lập trình B JavaScript thì không muốn sử dụng equal hai bằng mà phải dùng ba bằng đấy thì đây là một cái got khá là nhỏ và nếu các bạn sử dụng thư Việ Asus thì các bạn có thể các bạn sẽ muốn biết tới đó là kiểm tra về cái giá trị kiểm tra xem kiểu giá trị nó có phải kiểu giá trị mà bạn đang H vọng hay không cái điều này rất quan trọng và đấy là cái lý do vì sao mà mình thích sử dụng goang hơn là những cái ngôn ngữ như là Note GS hoặc là Python khi mà code cái dự án lớn đó là bạn muốn biết chắc chắn là cái kiểu dữ liệu mà bạn nhận được bạn muốn bạn muốn định Bạn muốn có cái tính năng là định kiểu chọng để bạn định kiểu được cái hợp để bạn đưa ra được những cái hợp đồng giúp cho việc tương tác giữa những cái module khác nhau ở trong dự án nó dễ dàng hơn giả sử như bây giờ bạn mình viết cái hàm Hello ở đây ở trong Python chẳng hạn thì mình sẽ còn phải thêm một bước kiểm tra nữa cái th của mình có phải là string hay không Nếu mà cái th của mình không phải là string và nó l là một cái class một cái object thì nó phức tạp thì lúc này cái quá trình cộng với string của mình nó sẽ bị sai và đấy nó sẽ ném ra những cái lỗi mà mình sẽ không thể kiểm soát được ở trong hệ thống của mình do đó là cái việc định kiểu chạt của go Nó là một cái mà khiến cho mình yêu thích nó khiến cho mình Tại sao mình muốn lựa chọn nó cho một cái dự án cỡ lớn nếu mà bạn chỉ prototype một cái dự án rất là nhỏ thôi thì mình cho rằng Python và go Nó sẽ rất là Python và JavaScript là những ng rất là đơn giản bạn có thể bắt đầu nhanh được nhưng mà khi bạn ở trên cái quy mô lớn hàng nghìn file đấy cái việc định kiểu trặc là một cái yếu tố mà mình rất cần thiết ok Thy là mình có assert vừa nãy thì bạn chiều có nói tới là viết móc thì chúng ta sẽ đưa ra một cái trạng thái ở trong cái cái thư viện database ở này đy giả sử cái thư viện database của mình trong cái package database của mình mình có m file ha là user.com cái database và mình định ra một cái type user data accessor và cái công việc cái type này là chỉ để truy cập những cái thông tin liên quan đến người dùng thôi tức là nó sẽ có những cái như là get user context context và ID chẳng hạn ID là một cái uin số4 đy mình sẽ có create user thì context context nó sẽ phải trả lỗi ở đây đấy mình sẽ coi nh cái đối tượng user của mình sẽ một đối tượng user rất đơn giản thôi Chỉ có hai cái thông tin đó là ID kiểu 64 và name str đấy thì sẽ có những cái thao tác như là get user sẽ cần phải trả về user Nếu mà không trả về user sẽ phải cóo lỗi create user để phải nh và một user và thông báo người dùng này và tạo người dùng này trong database mình sẽ cần phải có update user thì cũng sẽ sẽ nhận vào của cái đối tượng người dùng và cập nhật cái thông tin của người dùng này ở trong database và cuối cùng thì mình sẽ phải có một hoạt động là Delete user contex cont nhận vào một ID để xóa người dùng này đi Chả phải lỗi n mà cái việc chỉnh sử này thất bại đấy thì đây là một cái struck một cái một cái interface để tương tác với cả thông tin người dùng một cách phổ thông thường các bạn làm trong dự án sẽ cần phải thực hiện bốn cái thao tác crud này Thế thì mình logic của mình mình muốn là cái logic của mình sẽ chỉ phụ thuộc vào cái interface này thôi nó sẽ không phụ thuộc vào cái việc là ở phía dưới mình đang tương tác mình đang access tới data ở trong My cqu hay postre hay sq LINE đó Thế thì ở phía Hello của mình ở đây thì mình sẽ có một cái type là Hello logic hoặ là mình sẽ chỉ gọi là Hello thôi Bởi vì nó đã nằm sẵn tr nó nằm sẵn trong cái package của tên là logic rồi đấy và mình sẽ sử dụng user data accessor đó Ok hello r cl Block à t bị Ở Đây Rồi ok đó Thì bây giờ mình có cái logic Hello này ở đây mà cái logic Hello này đây sẽ sử dụng cái database liên quan tới người dùng để mà làm những công việc liên quan tới người dùng và ở đây như Các bạn thấy là mình đã phụ thuộc vào mỗi cái interface thôi chứ mình không phụ thuộc vào stru cụ thể thế thì vừa nãy bạn chiều có đặt ra câu hỏi đó là nếu bây giờ chúng ta tương tác với cả database thì chúng ta sẽ cần phải tương tác với cả móc và tương tác với cả móc thì có nghĩa là mình sẽ phải giả mình sẽ giả lập cái việc mà mình tạo người dùng hoặc là lưu trữa người dùng hoặc đọc người dùng từ database đấy Thế thì có hai cách để mà các bạn viết ra cái mó theo cái interface này Cách thứ nhất là các bạn viết thủ công mó user data accessor stock đó Cách thứ nhất là các bạn viết thủ công Đây là một cái strock rỗng và các bạn sẽ có new m user data accessor ở đây nó sẽ trả về một cái user data accessor nhưng mà ở phía dưới nó trả về Return accessor đấy và cái công việc bạn phải làm là các bạn sẽ phải điền vào bốn cái function này một cách thủ công để mà cái str móc user data accessor này nó tuân thủ theo đúng cái interface mà đã định nghĩa ra từ bên ngoài đây là cách thứ nhất làm thụ công Cách thứ hai là tự động hóa thì chúng ta có một cái thư viện ở bên Uber bây giờ là Uber đang maintain cái thư viện này nó là Uber mo Go mình sẽ quay lại sang SH s phía Chrome thì như các bạn thấy móc ở đây là một cái thư viện do Uber hiện tại đang maintain ngày xưa nó gọi là g ngày xưa nó Open source bây giờ nó vẫn Open source nhưng mà nó đang nằm trong quản lý của Uber thì cái khả năng của nó đó là bạn có thể sử dụng một cái lệnh có tên là B gen mo gen này sẽ nhận vào một cái file ví dụ cái file là Go là f. Go ở đây và nó sẽ sinh ra những cái loại nó sẽ sinh ra những cái str móc tuân theo cái interface Mà định nghĩa ra ở trong cái file source ví dụ như là ở đây thì mình đang có mo gen không biết là mình đã cài đặt m trên mánh của mình chưa m thì cái việc đầu tiên mình cần phải làm đó là mình sẽ sử dụng cái lệnh này Go install cái lệnh Go install ở đây cho phép mình là cài đặt cái package này và nó sẽ compile cái package này ở trên máy tính của mình nó sẽ compile cái package đấy thành một cái file binary để mình có thể sử dụng được cái lệnh mgen ở đây Thế thì mình sẽ quay lại Cửa sổ Visual Studio code chạy l Go install nó sẽ Download những cái này về xong nó sẽ compile cái file nó sẽ compile lại mo thành cái thư viện binary ở trên máy của mình đấy ví dụ hiện tại mình đang có version 4. 4 0.4.0 thì công việc mình có thể làm là m gen này và mình sẽ generate ra một cái file mình sẽ lấy cái source file source của mình nó sẽ bằng internal database user.com đó nó output ra đây là nội dung của một file câu V bây giờ mình sẽ có mình sẽ cần phải output ra một cái Destination nó sẽ mình sẽ muốn output ra cái file này ra cái file có tên là internal database user go. M.Go đấy thì bây giờ cái output của mình ra ở đây và như các bạn thấy là cái nó nằm trong cái thư mục mo database Nó bị sai bởi vì là cái mo bởi vì mình đã có cái thư mục mình đã nằm trong cái package database Ở Đây Rồi mình sẽ phải thêm một cái điều kiện nữa Ở đây là mình muốn sinh ra cái package này là một phần mình sinh ra cái file này như là một cái phần package database tr test database cũng được đấy thì lúc này cái file này nó sẽ không còn bị sai package nữa nó không còn là một cái package page lạ ở trong cái trong cái thư mục database này giờ chỉ có một package nh database không thôi mình sẽ Go ID để mà Download cái dependency là GX thì như các bạn thấy mình phải xóa cái này đi B nó bị va chạm V kia như các bạn thấy thì ở đây Chúng ta có một cái nó đã sinh ra cho mình cấu trúc dữ liệu gọi là mo user data accessor m user data assessor ở đây Cài đặt tất cả những cái cài đặt tất cả những cái hàm theo cái định nghĩa của cái interface data accessor mà có nằm ở trong cái file này tức là nó tuân theo cái interface này và ở trong tương lai nếu mà mình bổ sung thêm một cái hàm nữa vào trong cái interface này thì nó cũng sẽ tuân thủ theo cái interface đấy mình chỉ cần chạy lại móc Zen thôi và ví dụ như từ phía Hello test ở đây từ phía Hello test ở đây thì mình có thể tuyên bố là đầu tiên mình sẽ cần phải tuyên bố là cần phải có một cái m controller m controller là một cái cần là một cái cần thiết được sử dụng bởi cái thư mục Go như controller nó sẽ nhận vào cái test của mình nó sẽ nhận vào cái đối tượng testing CHT của mình và mình sẽ cần phải chạy cái lệnh defer moob controller finish để mà kết thúc cái việc control những cái mo của mình ở cuối cái test Thế cái việc mình có thể làm ở đây là mình sẽ tuyên bố là mình cần sử dụng một cái user data accessor và user data accessor này thì sẽ lấy ra từ database new m user data accessor mo controller đấy và mình muốn là cái cái đối tượng user data accessor ở đây nó sẽ khi mà được gọi cái hàm get user với cái input là g. any tức là input gì cũng được với giá trị bng 1 thì nó sẽ Return một cái giá trị là database user 1 user với ID 1 và name là ch minu và mình muốn là cái tha tác này sẽ thực hiện một [âm nhạc] lần đó Đây là một cái móc mà mình có thể điều khiển được từ trong bộ test của mình và cái đối tượng móc này chỉ tồn tại ở trong cái test này của mình mà thôi Điều đấy có nghĩa là cái đối tượng test cái những cái móc user data accessor ở trong test này nó sẽ không bị hình hồ bởi những cái mó user data accessor ở trong những cái test khác có nghĩa là bạn có thể viết test mà bạn không quan tâm là đồng nghiệp bạn viết test như thế nào mà ngược lại Bây giờ mình sẽ thử nhá user data assessor ch getuser ontex background và ID bằng 1 nó nhận vào input là một cái input của g user ở đây là một cái in 64 do đó nên mình cũng phải đảm bảo là cái kiểu dữ liệu của mình đúng là in uin 64 đấy Thực ra thì T Đảm bảo từ phía trên này hoặ D này thì không cần phải đảm bảo bởi vì cái này là một cái user bình thường rồi đấy mình sẽ nhận được cái thông tin user này và error này à mình bởi vì nó output error nên mình phải Return Return là new nữa chỗ này sẽ là assert ch new tr và ass ch equal t user với database CH user với ID bằng 1 và name trầ Minh Hiểu và cái user này nó sẽ phải bằng cái user này đó Ok thế thì mình có cái test này rồi chúng ta cùng thưng test nhá Go test internal logic Hello test ừ à Nó bị sai mất cái test say hello ở đây mình sẽ disable nó bằng cách là chuyển nó thành một cái file không phải là b các bạn có sự khác biệt đây nhá test này test viết thường đây sẽ không phải một file test test chuẩn là phải có cái chữ t đầu tiên viết hoa đấy pass đó giả sử bây giờ mình lặp lại cái quá trình này thêm một lần nữa nó sẽ báo lỗi vì sao Bởi vì mình đã định nghĩa là cái user data accessor của mình đấy Ở đây nó sẽ báo lỗi là unexpected call to this function unexpected cái là cái hàm này đã gọi tới một cách không được nhận không được bởi vì chúng ta xác định là cái hàm này chỉ được gọi tới một lần thôi cái lần gọi tới thứ hai nó sẽ báo lỗi là unexpected COD t tôi không Tôi không ngờ là bị gọi tới cái hàm này nên tôi sẽ báo lỗi vậy nên tôi mình có thể chuyển lại mình thể chuyển lại cái time này thành hai hoặc mình thể chuyển lại cái time này thành anytime vô số lần đế là cái test này nó sẽ lại pass bình thường đó thì goob là một cái công cụ thậ là mình không thể sống thiếu được khi mà mình lm chình bằng Go vì như các bạn thấy là cho dù là mình định nghĩa cả interface này bao nhiêu lần và mình nĩ định pha cái interface này có bao nhiêu hàm trắng nữa GX sẽ sinh ra cho mình được một cái stru tuân thủ cái interface này và mình có thể điều khiển được cái thao tác mình điều khiển được cái trạng cái input output của cái interface này từ trong bộ test của mình để mà đảm bảo rằng là Ok Nếu mà bây giờ cái logic của tôi là đang tương tác với người dùng như thế này và tôi tạo ra người dùng mới như này thì tôi sẽ xác định r sẽ có những cái lần gọi Vừ cái database của tôi như thế này về output như này về input như này nó giúp bạn là đóng gói cái bộ test của bạn không cần biết là cái những cái phần khác những cái mod khác của bạn có ra kết quả đúng hay không Bởi vì bạn là người điều khiển nó mà bạn là người điều khiển Cái móc của nó mà có thể mặc định rằng là những cái module khác là trả lời đúng và bạn chỉ cần test cái module mà đang sử dụng những cái module khác thôi Ví dụ mình có user logic chẳng hạn user logic của mình sẽ sử dụng user logic của mình sẽ bằng logic CH à [âm nhạc] Hello thì cái module của mình nó sẽ chỉ cần xem nào unn fiel user dat cler và mình sẽ sử lại cái này Quick đó thì như các bạn thấy là cái ví dụ như là mình có cái logic mà sử dụng database mình có thể cung cấp cho cái logic đấy một cái mó một cái cài đặt móc của cái interface của mình để mà nó Nó sử dụng để mà mình mình chắc chắn là cái mó của mình là chạy đúng rồi thì mình điều khiển mó mà Thì mình muốn kiểm tra ra là cái logic Hello của mình nó có hoạt động đúng theo cái tiêu chuẩn mà mình đặt ra hay không đó thì gobx là một cái công cụ mình không thể sống thiếu được khi mà mình lập trình bởi vì mình nó giúp mình là đóng gói được những cái module của mình hoạt động đồng lập với nhau thì mình sẽ gửi lại cho các bạn link của G ở trong chat test fixture cũng là một cái mà mình vừa mới nói từ vừa nãy test fixture thì mình nói từ trước rồi test fixture là cho phép mình là setup cái database của mình Ví dụ như mình có một cái logic mà đang tương tác v cái database mình muốn là database của mình có 10 dòng và mình muốn đảm bảo rằng là cái câu lệnh của mình chỉ xóa năm dòng mà thôi thì mình sẽ sử dụng test picture để đảm bảo là mình là lúc bắt đầu test mình có năm dòng mình có 10 dòng đấy thì test picture là đảm bảo là trạng thái của database nó sẽ độc lập nó sẽ độc lập với nhau Nó không bị ảnh hưởng bởi những cái lần Test Ok thế thì bây giờ nếu mà bạn muốn test những cái khác bạn chỉ không bạn không dừng lại ở việc là test với cả database bạn mà bạn muốn test với cả những cái thư viện bên ngoài bất kỳ ví dụ như là message que như capc hoặc là catch như là rit chẳng hạn thì lúc đấy chúng ta sẽ có một cái thư viện g test container test container V Câ mình sẽ quay lại share sang phía bên Chrome đây đó thì test container test container Thực ra là một cái bộ giải pháp mà nó khá là hỗ trợ nhiều ngô ngữ khác nhau như các bạn thể thấy là hỗ trợ cho Java nodejs Python các kiểu nhưng mà test có thể nó cho Go thì cho phép là cái thư viện mà các bạn dùng cho Go thì cái mà các bạn cần là bạn sẽ cần có một cái docker run ở trên máy của mình docker là gì docker là một cái docker là một cái hệ quản lý container container của bạn có thể hiểu là bóm gói cái tiến trình của bạn vào trong một cái môi trường kín đóng gói cái tiến trình của bạn trong một môi trường kín để đảm bảo là cái chương trình của bạn sẽ luôn luôn chạy ở trong cái môi trường mà Bạn định nghĩa cho nó ví dụ như là bạn muốn có một cái server mysql và cái server My squel đấy có người dùng như thế này với password như thế này thì bạn có thể download cái container của mysql về và chạy container đấy trên mà Hình bng thì lúc đấy Bạn không cần phải cài đặt bạn không cần phải lo là cài đặt myq Lên đâu nữa và lú đấy Bạn chỉ cần chạy cái container của myq thôi Hoặc ví dụ như bạn muốn chạy ngx Chẳng hạn nginx là một cái web server thì các bạn sẽ Download cái container của nginx về và setup cái contenter của nginx hoặc là ví dụ như sau này bạn deploy cái sản phẩm của bạn lên bạn có nghe cái câu đùa là nó chạy trên máy của tôi như không chạy trên máy khách không thì để đảm bảo là cái chương trình của bạn cũng chạy trên máy của khách được thì lúc này bạn sẽ đóng gói cái chương trình của bạn và trong một cái container để đảm bảo là mình sẽ shift cái môi trường mà các bạn lập trỉ cái dự án của mình lên trên bất cứ cái nơi nào mà bạn deploy sản phẩm lên Nếu bạn deploy lên trên máy của khách khách chỉ cần chạy container của cái chương trình của bạn thì sẽ đảm bảo là cái chương trình của bạn sẽ có đầy đủ những cái file như bạn muốn ở trong cái môi trường làm việc của nó thì test Container là cho phép bạn có thể sử dụng điều khiển những cái container từ phía bên ngoài Ví dụ như ở đây chúng ta có test container sẽ setup một cái server redit Server redit này sẽ chạy ở Port 6397 theo cái cố pháp TCP và mình sẽ đợi cho đến khi nào mà cái container này log ra cái dòng là ready to accept connection có nghĩa là lúc đấy Cái server ready này đã sẵng sàng để mà đón nhận những cái kết nối từ phía client redit của mình đấy Sau đó thì mình sẽ sử dụng cái lệnh là test container generic container ở đây để mà Download cái image rit về setup cái container rit và chạy cái server redit đấy ở trên máy của bạn lắng nghe ở cổng 63 79 sau khi mà bạn có cái server redit đấy đã chạy Xong rồi thì lúc đấy Bạn có thể nghịch với cái server đấy Kiểu gì cũng được có thể test cái logic của bạn trên đấy b thể test xem là cái logic C của bạn có hợp lý hoạt động ok không Hoặc là với server mysql thì các bạn kiểm tra xem là cái query của bạn có hợp lễ hay không Bạn có thể kết hợp cái này Cùng với cả cái test fixture mà mình nói Cách đ Mấy phút sau khi bạn test xong hoặc là trước khi mà Bạn test thì bạn có thể sử dụng defer để mà bạn sử dụng lệnh là redit redit c. terminate để đảm bảo là tất cả những content mà bạn tạo ra bởi test container sẽ được dọn dẹp gọn gào khi mà cái bộ test này kết thúc thì đấy là test container công ty mình có một giải pháp nộ bộ trong cái này rồi nên bọn mình không sử dụng test container Nhưng mà nếu mà mình code và cái dự án cá nhân bên ngoài và mình muốn viết unit test mà tương tác với những cái module bên ngoài thì chắc chắn là Phả sử dụng test container Ok Thì đấy là ba cái thư viện mà mình vừa mới mình tới ra là mình đã nói qua bốn thư viện assert m test picture và test container một cái nữa mà các bạn nào mà đã từng lập trình về JavaScript Nếu các bạn lập trình JavaScript thì các bạn có thể biết là mình nhớ tên không nhấm jasmin rồi jasmin là một cái bộ test đây thì bộ test của jasmin nó nó có cái cú pháp như thế này describe suit the of function ở bên trong thì bạn muốn kiểm tra là itt nó phải đảm bảo điều kiện gì đó ví dụ ở đây là tôi muốn điều kiện đảm bảo là a nó có gi trị bằng true đúng không ạ thì các bạn sẽ mô tả bộ test các bạn sử dụng cái cú pháp như thế này Đấy là một cái đấy là một cái cú pháp test mà được phổ biến bởi ngôn ngữ jasmin và cho phép bạn có thể định nghĩa là bạn thể viết ở đây là mô tả là test của bạn đang làm cái gì Ví dụ ở đây là tôi đang test cái A và tôi muốn cái A này nó phải hoạt động như thế nào Tôi muốn cái A này phải giá trị bằng true thì bạn sẽ sử dụng những c ph it và sau đó bạn mô tả cái điều kiện đấy ở trong cái function ở đây thì giống hệ như jpin ở phía go Nó sẽ có một cái thư viện có tên là gco đó ngin c c testing đây nó cho phép bạn viết những cái test cũng giống giống hệt như cái cú pháp ở phía bên jasm như thế nó sẽ là như thế này chẳng hạn Đây đây là bộ test dành cho book book ở đây thì tôi có đối tượng book như này trước khi bắt đầu test thì tôi muốn setup là cái l meet nó là như thế này và Fox shop nó giá trị như thế này tôi muốn mô tả tại cái bộ test lên trên book của tôi bộ test trên book của tôi thì nó sẽ bộ test này sẽ độ dài là nhiều hơn 300 trang thì tôi sẽ kiểm tra là expect kỳ vọng là less miserable nó sẽ phải có category nó phải equal với category novel đấy và tôi kh đảm bảo là F inof ch category nó sẽ equal với book. category Short story đấy thì nếu mà nếu mà các bạn muốn viết test mà các bạn rất là cái cú phép test phổ thông của Go thì nó như kia mỗi một cái function là một test và cái đấy thì là cái mà mình thích dùng Nhưng nếu mà các bạn mà quen sử dụng với cả cái cố phóc của phía bên JavaScript sử dụng jasmin mà sử dụng describe expect describe it expect thì các bạn có thể sử dụng Gin cá nhân mình thì mình không nghĩ ra cái lý do gì mà tại sao mà mình lại muốn sử dụng kinco hơn cái bộ test chuẩn của Go cả vì gco có nghĩa là mình sẽ phải bổ sung thêm một cái test nữa một cái Framework test nữa vào trong cái chương trình của mình và mình thấy là cái Framework test của Go nó khá là đủ dùng với mình rồi Nhưng nếu mà các bạn có xất phát điểm là từ phía JavaScript Sang và các bạn quen sử dụng jasmin thì chắc các bạn sẽ quen thuộc với cái này Ok Thì đấy là năm cái thư viện mà mình nghĩ là mình sẽ khá là giá trị khi mà các bạn sử dụng với cả việc testing ở phía câu có bạn nào có câu hỏi gì liên quan đến những cái này không ạ cứ tự nhiên nhá bật mic hỏi cũng được cho mình hỏi thì thường Project của bạn sẽ có bao nhiêu loại test vậy Project hiện tại của mình Mình sẽ có unit test in test bằng C test Framework và end to end test thì mình sẽ sử dụng test container đây là với cả dự án Open source của mình thôi nhá Thực ra thì còn dự án tức là về phía trong công ty của mình thì mình sẽ có cái bộ test sử dụng Go test và end to end test thì bọn mình có một cái nó rất giống rất giống test container nhưng nó không phải test container thì mình sẽ viết hai cái test như vậy Ờ các công ty lớn thì thường nó sẽ có thêm những cái môi trường như là kiểu staging nó sẽ có m nó sẽ có những môi trường như là test này uit này staging này và live production thì test là cái nơi mà một cái bãi chiến trường các bạn muốn đập gì thì đập các bạn deploy lúc nào bạn đấy là cái môi trường dành cho de uat nó là user test thì it Nó là cái nơi mà các bạn sẽ deploy lên đấy để mà đưa qua review với cả phía ví dụ là người đặt hàng Pha chờ bạn là pm Project Manager chẳng hạn th lúc này uat là cái nơi mà các bạn sẽ deploy lên đấy và các bạn sẽ dùng Cái đấy để bạn review bạn demo với cả bên pm rằng là cái dự án test của bạn nó hoạt động Ok và lúc này thì khi bạn lên tới u thì bạn phải công nhận là thì lúc đấy bạn phải kỳ vọng là cái cái tr của bạn nó đã hoạt động với cái độ chính xác nó giống như là ở trên production rồi bởi vì lúc này bạn đ demo về những người mà có phả có thể là nonte sau khi mà tới uit rồi thì bạn sẽ có staging và staging thì lúc này cái staging ở đây mình cũng không rõ staging dng gì nữa chắc một bướ đệ nữa nhưng mà có một cái mà mình thường hay thấy là có test nó là integration testing thì integration testing mình như ngày xưa thì mình làm shope thì testing được làm ở trong môi trường test environment mình làm trong môi trường test environment bọn mình sẽ có một số cái thư viện Ví dụ như nếu mình không nhớ không nhầm thì nó tên là gì nhở cfly Ừ ok testing mình không nhớ là cái thư viện đấy nó có tên bởi vì nó một cái thư viện Open source Ok integration [âm nhạc] testing service record [âm nhạc] st interation testing mình khi nào mà nếu mình nhớ ra thì mình sẽ gửi lại vào trong discord nhưng mà về cơ bản thì như thế này Nó là một cái Framework mà ở trong đó mình có thể ghi lại traffic giữa những cái service của mình Ví dụ như là mình đang có một cái service a service này liên hệ với cái service B mình đ muốn đảm bảo rằng là cái service A nó sẽ hoạt động đúng khi mà cái service B nó output như thế này thì mình sẽ có hai bước bước thứ nhất là mình sẽ test và khi mà mình bước thứ nhất mình sẽ test ở trên cái môi trường test Lúc này cả service A và service b đ là service thật mình sẽ sử dụng một cái thư viện trung gian để mà lưu để mà ghi lại những cái traffic tương tác giữa a và b đó thì khi mà mình đã ghi lại tương tác giữa a và b rồi Lúc này những cái tương tác đấy sẽ được đóng góa lại thành một file json và về sau khi mà đưa lên trên ci khi mà đưa lên trên cdci thì lúc này mình sẽ chạy lại những cái tươn tác đấy thì lúc này sẽ chỉ có service A là đang online thôi service B tất cả những cái output của service b sẽ được móc bởi cái tương tác mà được ghi chép lại Bởi cái thư viện bên ngoài kia thì đây là integration testing nó là đảm bảo nó đảm bảo rằng là cái service của mình nó sẽ hoạt động chính xác dựa trên cái output của service khác để đảm bảo là cái sự integrate cái sự kết nối giữa những cái service là chính xác các bạn có thể có tên gọi khác trong cái đấy nó có thể gọi là end testing mình nhưng mà Bình thường thì mình sẽ có hai tên có có hai t gọ cho đó là integration testing hoặ là ent testing performance test thì performance test thì lúc này nó sẽ không nhất thiết phải được thực hiện bởi cái performance test thì lúc này nó là mình đang đo đường cái hoạt động của mình là cái hệ thống của mình có thể phục vụ được bao nhiêu request trên 1 giây thì cái này thì nó không thực sự thường thì mình sẽ sử dụng một cái thư viện bên ngoài và cái này không phải là col là locus locus là một cái thư viện bằng Java bng Python nó có một cái giao diễn web thì khi mà các bạn chạy locus thì bạn sẽ có cái giao diện web này nó cho phép bạn là target vào cái host ở địa chỉ như thế này bạn có thể nhìn thấy là cái stus của nó hiện tại là đang có bao nhiêu cái client đang chạy song song với nhau để mà cùng bắn request về phía server với vận tốc là bao nhiêu request trên giây và cái failure rate là bao nhiêu Có bao nhiêu request trả về với lỗi 500 thì mình sẽ sử dụng locus để mà mình test xem là nó để mà mình có giao diện web để mà dễ dàng tương tác với cả cái quá trình str test của hệ thống của mình thì cái này nó không phải Go nữa Cái này lúc này th nó lúc này thì cái performance test thì bình thường ấy performance test thì nó là một khi mình sẽ performance test với cái tâm thế là blackbox testing có nghĩa là mình không quan tâm cái servit ph dướ Nó được cài đặt như thế nào Nó có thể được cài đặt Java Python nots Go Không phải vấn đề của mình nhưng mà trong cái vị trí của mình nếu mà vị trí của mình như là một tester thì mình sẽ muốn là Ok mình có một cái api như thế này mình cho một cái hợp đồng như th này mình có thể tương tác với những cái endp như thế này ở cái địa chỉ server như thế này thì mình sẽ viết test như thế mình sẽ dùng locus để mình bắn request càng nhiều càng tốt về phía server sử dụng cái thư Việ như thế này thì cái này nó không phải có L nữa và bình thường performance testing thì mình viết per viết perform test thì lúc đấy bạn sẽ không mình không nghĩ là các bạn sẽ viết performance test sử dụng một ngôn ngữ cụ thể bởi vì lúc này là performance thì nó có thể là lúc đấy bạn thể lựa chọn giữa Go Python với cả những cách cài đặt khác rồi nó khác với cả unitest unitest của bạn là đi chặt với cả code Go nhưng mà performance test nó khác performance test Lúc này là cái tương cái cái diện mà bạn tương tác sẽ đ diện ở trên Black b chứ không chứ không Black một cái service Black box chứ không phải là về phía Từng dòng 1 như là integration testing hoặc là như unit [âm nhạc] testing Ok có bạn nào có câu hỏi dì khác không ạ Ok một cái hay nữa Mà mình muốn nói về Go và cái này thì nó không thực sự liên quan đến test nhưng mà nó sẽ rất ích cho các bạn trong tương lai sẽ quay trở lại về phía quay trở lại phía Visual Studio code vừa nãy thì mình có sử dụng cái lệnh đó là mo Zen và mo Zen như các bạn thấy đây Chúng ta có ba cái output đây đó m Zen ở đây thì mình có ba cái input input thứ nhất đó là database là cái file gốc nó nằm ở đâu input thứ hai nó là cái file output nó nằm ở đâu và cái input thứ ba sẽ là cái package mà cái file này nằm ở đâu đấy Thế thì bây giờ mình không muốn là mình phải gõ cái dòng này V bất cứ một cái file nào có interface trong chương trình của mình mình không muốn mình phải gõi lại dò này thì go có một cái cơ chể rất là hay nó là buil đấy Nó là một cái dòng comand bình thường nó một dòng comand bình thường ở đây thì ví dụ mình sẽ đây là go generate đó Go generate và cái buil ở đây mình muốn go go generate đây có nghĩa là mình cái bu ở đây là nó sẽ dùng để tương tích tươ tương tác về cả lệ Go generate thì mình sẽ p thêm cái dòng Comment mình vừa sử dụng ở đây thì cái dòng Ở đây có nghĩa là đối với cái file này thì hãy chạy cái lệnh này với cái file này cái file ở đây thì mình sẽ thay thế tên file thay vì dùng tên file thì mình sẽ sử dụng để mình chạy lại đ comment ừ đây mình sẽ sử dụng cái này goof và Destination của mình sẽ là goof chm Go và package của mình sẽ sử dụng cái biến môi trường là Go package Nhưng mà thêm đa test Go package thì cái chuyện xảy ra đó là mình có cái cái dọc này ở đây mình có thể sử dụng cái lệnh mình có thể sử dụng lệnh là Go generate internal database user.com Khi mà mình chạy Xong mình sẽ có cái file này đây mình có thể xóa cái file này đi để mình nhìn lại thêm cái đấy m lần nữa đó thì như các bạn thấy đây thì cái sao check lại file này new m user data assessor Ok nó ở đây rồi đó thì như các bạn thấy ở đây ấ thì cái dòng command Line ở đây cái dòng ở đây nó có ý nghĩa như sau Thứ nhất là Go 2. generate điều đấy có nghĩa là cái lệnh cái command ở đây nó sẽ được tương tác với cái lệnh Go generate để bạn có thể sin code cái thứ hai ở đây chúng ta sẽ yêu cầu là khi mà chạy Go generate thì đối với cái file này sẽ cần phải chạy dùng lệnh m Zen m Zen thì nó sẽ nhận những cái input là source source ở đây thì mình sẽ truyền vào Go File là cái tên của cái Go tên của cái file Go mà hiện tại cái dòng này đang nằm ở trong cái Destination cái output thì nó cũng sẽ là cái Go file đế nhưng mình sẽ thêm một cái đuôi nữa là M.Go để nó vẫn là một cái file Go hoàn chỉnh và mình sẽ truyền cái input package là Go package để mà cái file được sinh ra nó cũng sẽ có cái nó cũng sẽ nằm trong cái package mà cái file này nó nằm bên trong đấy thì như các bạn thấy khi mà mình chạy Go generate thì nó sẽ chạy lại cái command này nó sẽ điền những cái giá trị chính xác vào ba cái chỗ Go file Go file và Go package này để mà dùng cái lệnh móc gen để mà sinh ra cái file này thì điều này có nghĩa là gì điều này có nghĩa là từ nay trở đi với cái dòng command này thì mình có thể copy cái dòng command này và để lên trên bất cứ một cái file nào ở trong cái dự án của mình Mình không cần phải quan tâm mình nghĩ nó như một cái Black bo thôi mình ôm cái dòng này mình mình paste lên bất cứ một cái file nào ở trong cái dự án của mình và Từ đó trở đi Khi mà mình chạy go generate Nó sẽ sinh ra được cái file MX cho mình mình cũng có thể chạy Go generate giống như với test thì mình sẽ chạy Go generate ví dụ interface như thế này internal nh nó sẽ chạy Go generate lên tất cả nh cái file ở trong cái thư mục internal của mình và đu đó có nghĩa là tất cả những cái file nào mà có cái dòng này nó sẽ sinh ra Móc được cái dòng đấy nó sinh ra móc trong cái file đấy mình sẽ paste cái dòng command này ở trong chat đó các bạn có thể bỏ cái dòng comand này lên trên bạn có thể bỏ dòng Comment này lên trên cái code của bạn và nó sẽ sinh ra được cái móc cho bạn ở trong tất cả cái dự ở trong tàn Bộ dự án của bạn đó thì một cái dòng command như thế này nó còn được gọi nó còn nó có tên gọi là built built là khi mà coman của bạn nó như thế này sợt sợt và nó không có dấu cách ở giữa built có thể có thể dùng cho nhiều cái nhiều cái tác Vũ khác nhau cái đầu tiên mà các bạn có thể thấy ngay đây là Go generate nhưng mà một cái thứ hai mà nó có thể sử dụng nó rất hay đó là các bạn có thể chỉ định là ở trong môi trường như thế nào thì nó sẽ thì cái file này sẽ được Ừ dùng trong cái việc buil giả dự như này các bạn có giả dụ như này các bạn có một cái file các bạn có một cái giá trị operating system Bạn có cái giá trị này và bạn muốn cái giá trị này nó sẽ là Windows nếu cái chương trình của bạn là chạy trên windows Và linus nếu mà chạy trên Linux maos Nếu chạy trên macos thế thì các bạn có thể sử dụng logic để mà các bạn kiểm tra xem là cái hệ điều hành của bạn là đang ở đâu nhưng mà một cách hay hơn đó là các bạn sử dụng bu thì giả sử bây giờ mình có file là os.get database và mình tuyên bố built của mình là dành cho những cái dành cho những cái Build và nằm Go view m đấy thì cái file này nó sẽ chỉ được Build file này nó sẽ chỉ nằm ở trong những cái Build nào mà có Tag đó các bạn Thể tìm cái mục s ở trong cái này đây đó khi bạn chạy lại gobu thì bạn thể cung cấp một danh sách các tag và các tag đấy nó sẽ quyết định là các bạn sẽ cung cấp các bạn sẽ cho những cái file nào vào trong Build và loại bỏ những cái file nào vào trong Build thì ví dụ như là ở đây mình có buil Tag Go buil mos chẳng hạn thì mình ở đây mình có thể định nghĩa là V operating system bằng ma đấy và có thể mình sẽ có thể đi thê một cái file nữa Go à linus và câu linus ở đây thì nó sẽ định nghĩa là cần phải Build cho Mội trường Linux và operating system lúc này nó sẽ bằng Linux đấy nó bị hiển thị đỏ ở đây bởi vì là nó đã bị redeclare ở Block này rồi mình sẽ xoa đây đi Bạn thấy là cái file operating cái operating system ở đây và operating system Ở đây nó không báo lỗi Cho dù cả là hai cái biến có cùng một tên hai biến có cùng một tên ở trong cùng một package thì tại sao nó lại không báo lỗi thì là bởi vì cái cơ chế buil tag ở đây buil tag là nó sẽ xác định là cái file này nó chỉ được bao gồm nó chỉ được nằm trong dự án của bạn Nếu bạn đang buil ở trong môi trường mos C cái file này ở đây nó sẽ chỉ được bao Hàn Nếu mà trong môi trường Linux mà thôi Do đó nên là ở trên một máy tính một cái máy tính thì chỉ có thể là hoặc là chạy mos hoặ chạy Linux thôi thì nó sẽ sẽ chỉ có một file là được bao gồ vào trong dự án của bạn và khi bạn Build dự án thì sẽ cũng chỉ có một file được L được lấy ra để mà quyết định là cái giá trị operating system này nó có nghĩa là gì thì viewt là một cái cơ chế rất là đặc biệt mình thấy là ở trong câu nó cho phép mình Build ra được sản phẩm mà chạy trên nhiều nền tảng khác nhau nhưng mà với cái logic nó hơi hơi khác biệt một chút cho các nền tảng khác nhau Nó rất là dễ và bạn không cần phải dùng hẳn cái dòng này ra bạn không cần phải tuyên bố hẳn cái dòng này ra và bạn có thể sử dụng đuôi của file như các bạn thấy cái file này nó đã có đuôi là linus rồi thì bản thân cái đuôi Nếu mà cái đuôi của file có tên là linus thì có nghĩa là cái file này nó đã nằm nó đã có cái tag là linus th bạn không cần phải chỉ định hẳn ra nó có T linus nữa cũng giống như cái file này các bạn có thể đặt cho tên của nó là s rwin BL Win là tên của Cái lõi tên của cái kel của maos thì lúc này cái file này nó sẽ mặc định là nó có cái T là D Win rồi và các bạn sẽ không cần phải chỉ các bạn không cần phải chỉ đích danh nó ra là cái T của nó là D Win nữa T thì có thể nó sẽ còn ngoài cái tên của cái colel ra ngoài tên của cái hệ điều hành ra thì nó sẽ còn có một cái cơ chế nữa đó là tên của kến Trúc chip Ví dụ như bạn có thể có Darwin dành cho am 64 hoặc là Linux dành cho AMD 64 tức là chip Intel và chip đấy thì hai cái cơ chế này là đâ thì cái cái cơ chế th Nó là một cái cơ chế cho phép bạn điều khiển được xem là cái logic nào sẽ được nằm ở trong Bill của bạn và cái logic nào sẽ nằm ở ngoài Bill của bạn ngoài cái việc các bạn chỉ định ra là nằm trên pl bu dành cho platform nào thì các bạn cũng thể dùng để chỉ định ví dụ là một một số feature nó sẽ hoạt độngở trên bản pro nó khác với bản community thì những cái tính năng đấy các bạn có thể những cái tính năng đấy các bạn có thể sử dụng th để các bạn quyết định điều khiển thì mình sẽ gửi lại cho các bạn thứ nhất là mình sẽ gửi cho các bạn cái documentation cái documentation của về những cái danh sách biến mà có thể xuất hiện ở trong cái dòng Go generate này ngoài Go file và Go package ra thì các bạn có thể truy cập đến những cái file khác những cái dòng những cái biến khác như là goart cái kiến trúc của qu Chip mà bạn đang chạy goos là cái hệ điều hành mà bạn đang chạy còn là goot là cái địa chỉ của cái của cái bộ phát triển phần mềm Go của các bạn Thứ hai là mình sẽ gửi cho các bạn về cái cơ chế T của câu [âm nhạc] ừ view package Custom Go binary mình nhớ là có cái bài viết chính thức của Go rồi during part the Ok thì tóm lược lại là chúng ta vừa đi qua cái cơ chế gọi là mình đi qua là bag có thể sử dụng làm gì BT có thể hỗ trợ những cái công việc tiện lợi như là đặt thêm cái dòng Go generate để tương để tương tác với cả cái lệnh Go generate ở trong goline hoặc là để sử dụng để mà chỉ định xem là những cái file nào sẽ nằm ở bên trong bên ngoài Build của bạn khi mà bạn Build ở trên những cái nền tảng khác nhau Ok có bạn nào có câu hỏi gì liên quan đến những cái mục này m những cái mục vừa nói không ạ Ok không ai C Hỏi gì đó Thế thì nhìn chung thì cái mà mình một cái rất hay mà mình nhìn thấy ở trong câu là cái Go generate như thế này tức là Go được thiết kế với cái chủ đích đó là nó giống như nó có sức mạnh của C C nhưng mà nó có cú phát đơn giản nó có sức nó có sức mạnh như là kiểu của C C nhưng mà nó phải đơn giản và bởi nó đơn giản Go là một trong những cái ngôn ngữ mà có í Keyword nhất và có cú pháp đơn giản nhất là có những cái data structure như các bạn học trụ bổi đầu tiên là đã buư sẵn ở trong dự án rồi bởi vì nó có cú pháp đơn giản Nên là các bạn có thể tích hợp được những cái tool như là Go generate để mà sin code sin code này không phải sin code dựa trên ai mà là sin code để mà giúp tự động hóa những cái công việc thủ công lẳng nhằng ở trong cái quá trình B làm việc ví dụ như là mó chẳng hạ móc này từ khi mà mình có Go mình sẽ không cần bao giời viết cái mstu cho mình nữa Hoặc ví dụ như là bạn có thể mở rộng ra Ví dụ như là bạn có thể sinh ra được cái logic để mà xử lý server http chúng ta sẽ share sang một chút sang bên cửa sổ của phía Chrome ở đây thì có một cái chuẩn gọi là Open api mình sẽ chúng ta sẽ học được về cái chuẩn này trong một vài buổi tới nhưng về cơ bản thì Open api Nó là một cái chuẩn để cho phép bạn có thể à đ bạn có thể tóm tắt lại được cái api của bạn Nó nhìn chung như thế nào Ví dụ như là Open api p store example thì khi mà các bạn có một cái file open api Ừ đây ví dụ như cái file the p Open api Editor khi mà các bạn có một cái cái file yamal và cái file yamal này nó mô tả là cái api của bạn nó có những cái endp gì nó hỗ trợ những cái cú pháp như thế nào đây ví dụ như cái api của mình nó sẽ có những cái endpoint như này nó hỗ trợ ph pháp tương tác về add và tương tác V store và tất cả những cái đấy đều được định nghĩa B bở cái file Yam ở phía bên tay trái ở đây thì khi mà mình có một cái file Yam như thế này rồi thì mình có thể tựa động hóa ra rất nhiều thứ mình có thể tự động hóa được cái việc sinh ra cái document ở phía bên phải đây nhưng mà V về phía go Nó có thể tự động hóa được cái việc là sinh ra được code cho cái server và phía client phía server phía client của mình có thể sinh ra để có thể tự độ hóa đ cái việc sin code À đây ví dụ như là đây chng mình sẽ generate server cho ngôn ngữ go đó và nó download ra đây rồi thì khi mà mình đã sinh ra được cái file này rồi thì mình sẽ mở cái file này ra ở trong phía Visual Studio code Ừ x y này Go này api router Ok share về Visual Studio code thì như các bạn thấy thì cái phía bên phía Yam bên phía Go ở đây t cùng một cái api đấy nó có thể sinh ra được những cái h nó sinh ra như thế này nó tức động sinh ra là tôi sẽ hỗ trợ cái api ở cái địa chỉ get api V3 ở đây hoặc là api V3 P ở đây se api I ở đây đấy thì tất cả những cái quá trình mà bạn thấy là nó thủ công như là việc là viết móc hoặc là cái quá trình viết cái logic để xử lý api endp những quá trình đấy thường là đã có một ai đó tự động hóa hộ bạn rồi và nếu mà có ai đó tự động hóa hộ bạn bằng những công cụ như là gó thì các bạn có thể sử dụng những cái lệnh như m gen để mà generate ra cái code đấy Nó giúp cho cái việc Bạn phải tập bạn có thể tập trung được vào việc code những cái logic core của hệ thống hơn là việc tập trung đi Viết những cái này món cách thủ công nếu các bạn viết cái này một cách thủ công các bạn cũng có nguy cơ các bạn viết sai thủ công mà con người mà bạn có thể viết sai ví dụ Các bạn có thể viết Cre ở đây và các bạn có thể viết thiếu mất một chữ e ở đây và rất nhiều người sẽ không để ý đấy Ở đây mình đang có spell check nên là mình nhận ra Ví dụ như mình viết created ở đây chẳng hạn mình sẽ không nhận ra mình viết thiếu một chữ d mình viết thếu một chữ d và đây có thể là một cái bố thay vì là mình tập trung vào việc viết những cái logic lặp đi lặp lại như thế này và nó khiến cho mình không đạt được cái hiệu suất cao nhất có thể thì mình sẽ sử dụng những cái công cụ sin code Như là kiểu Open api generator để mà sinh code ra cho mình tự nhiên là móc gen để sinh ra code cho mình một cái công cụ nữa mà rất là hay mà mình muốn chia sẻ với các bạn và đây cũng sẽ là một cái mình muốn các bạn H vọng các bạn có thể áp dụng được trong cái công việc code hàng ngày có một cái cấu trúc dự án Cái này không phải là là một cái ở trong mỗi ngôn ngữ Go và nó sẽ là một cái cấu trúc dự án ở trong nhiều ngô ngữ khác nó có tên là dependency injection dependency injection có nghĩa là một cái cú pháp khi mà ở đó bạn tuyên bố là bạn cần những cái cấu trúc dữ liệu A cần những cấu trúc dữ liệu B logic của bạn sẽ cần phải tương tác với database user tương tác với database order tương tác với database đơn hàng đấy à Cái server của bạn sẽ cần phải phải có logic người dùng logic đơn hàng logic sản phẩm đó thì những cái A Cần cái b như vậy ta gọi nó dependency Tức là yêu cầu phụ thuộc vào nhau thì dependency injection là một cái cấu trúc mà ở đó bạn sẽ viết code mà bạn sẽ ở đây bạn sẽ tuyên bố là code cái A Cần cái B nhưng ở bên trong cái A bạn sẽ không có nói là cái B được cấu thình như thế nào mà các bạn sẽ để cái việc khởi tạo việc cái B bạn sẽ khởi tạo cái B ở bên ngoài rồi bạn sẽ nhém bạn sẽ ném nó vào trong cái A một cái ví dụ đơn giản ở ngay trong cái dự án Hiện tại chúng ta thấy ở đây như các bạn thấy ở đây thì cái user logic ở đây của mình Hello logic ở đây hello logic ở đây của mình sẽ cần có user data accessor nhưng mà giả dụi bây giờ mình có một cái function new Hello logic và new Hello logic ở đây mình sẽ không biết là mình cần phải có user data assess mình sẽ mình sẽ không viết là mình có mình sẽ không viết là cái user data accessor này nó sẽ được cấu thành như thế nào mình sẽ nói là mình cần một cái user data accessor nhưng mình sẽ không khởi tạo cái user data assessor này từ phía bên trong của cái Hello logic và tại sao mình lại làm như vậy tại sao mình lại làm như vậy thì cái lý do mình làm như vậy là để mình để cái việc khởi tạo mình để cái việc khởi mình trao cái việc trao cái trách nhiệm khởi tạo cho cái user data assess này cho một cái phía bên ngoài và điều đó có nghĩa là là mình sẽ có thể inject mình có thể ch cái user data accessor này mình có thể bên ngoài có thể chèn vào bất cứ một cái user data accessor nào miễn là nó tuân theo cái interface này điều đấy cho phép mình có thể nhanh chóng là thay đổi cái logic mà mình sử dụng ở trong code của mình cái user data accessor này có thể là một cái data accessor thật nó tương tác với cả server My hoặc postre Nhưng mà nó cũng có thể là một cái móc us đã s mình sẽ sử dụng vào trong Unit test đấy thì cái cú pháp dependency injection này nó không phải là cái gì kỳ lạ cả nó là một cái mà đã xuất hiện ở trong nhiều ngô ngữ khác rồi Tuy nhiên thì cái việc mà sử dụng dependency injection nó có một cái nhược điểm đó là cái quá trình khởi tạo dự án nó rất là dài Ví dụ như ở trong cái lệnh command ví dụ trong khi mà mình khởi tạo dự án th ạ thì công việc của mình là đầu tiên là khởi tạo config này xong rồi à inject config vào database stru đó xong rồi ở đây thì có thể có n database str Xong rồi inject config vào catch stru có N2 sau rồi bạn sẽ có inject database struck và C str vào logic str ở đây thì sẽ có N3 cái strock như thế và mỗi một cái strock như thế Chúng ta sẽ cần phải có n cộng N2 xong rồi là inject à logic stru vào handler stru handler đây có thể là server http thì nó sẽ là tổng cộng là có thể là khoảng ba bốn cái nhân với cả số lượng mà logic mình cần phải inject vào là N3 đấy thì tổng cộng số lượng dòng mà mình cần phải viết để mình khởi tạo hết cái quá trình này nó sẽ là 1 cộng n cộng với cả N2 cộng với cả N3 nhân với cả N1 cộng N2 cộng với cả 3 bốn cái nhân với N3 nói chung là rất là nhiều đấy anh thử lấy hai ví dụ dùng dependency và không dependen đi đây mình có thể làm như thế này Đấy ví dụ như là mình có cái struck đây h mình Type config và config của mình thì sẽ có một cái stru và stru đây sẽ chứa một số cái thông tin quan trọng ví dụ như là database user string và database password cũng là string đy và mình có một cái type là user data accessor là str và rõ ràng là cái user data accessor này sẽ cần phải có config cần phải truy cập đến config rồi đúng không Mình không chỉ có mỗi user data accessor mình sẽ cần phải có những cái khác như là Order data accessor xong gọi là product data accessor đấy đó Đây mới chỉ là bước database thôi nhá Bây giờ mình sẽ có một cái khác là typ à marketplace logic đấy marketplace logic marketplace logic thì rõ ràng là sẽ cần phải có truy cập đến user data assessor rồi cũng cần phải có order data accessor này cần phải có product data accessor này đây xong ngoài marketplace ra thì mình sẽ cần phải có ví dụ như là social logic social logic là tương tác người dùng người dùng thì lúc này sẽ cần phải truy cập tới user data accessor và có thể sẽ cần phải có thêm một cái nữa Ở đây là post data accessor để mà truy cập đến những cái như là kiểu mạng xã hội chẳng hạn người dùng aost lên một cái người dùng b đấy và cuối cùng là mình sẽ có một cái ty server server của mình sẽ là một cái server sẽ cần phải có tất cả những cái logic của mình thì bao gồm social logic và market logic đúng không đấy thì giả sử nếu mà mình không có depend nếu mà mình không làm theo dependency injection thì mình sẽ khởi tạo new server nó sẽ trả về một cái server đúng không Thì quá trình khởi tạo ở đây sẽ là à config bằng với cả config x đấy Xong rồi có user data accessor sẽ bằng cái user Data accessor với ở bên trong đấy tương tự như thế mình cũng sẽ Phả cần phải có order data accessor bằng chm chấm chấm post product data [âm nhạc] accessor 3 chấm 3 chấm chấm đấy xong mình sẽ cần phải tạo ra social logic marketplace logic chấm chấm chấm đ cuối cùng là return một cái thằng server cho tất cả mọi thứ cái vấn đề ở đây đó là nếu mà giả sự vừa nãy mình mình đang dùng trực tiếp cái user data accessor ở đây nhớ Bây giờ mình cần phải unit test cái cái Server này và mình muốn thay cái data accessor này bằng móc thì sẽ như thế nào mình sẽ không thể làm được mình không thể làm được vì điều đấy có nghĩa là mình sẽ cái hàm new server ở đây mình sẽ phải chỉnh sửa cái hàm new Server này có nghĩa là mình sẽ phải viết một cái hàm new server giạch riêng cho việc móc và điều đấy là không thể đ đấy mình điều đấy sẽ yêu cầu là sẽ rất kh nó sẽ cần phải viết rất nhiều hàm bạn có user data rồi nh X này bạn phải m marketplace data accessor hay sao hoặ ví dụ như bạn phải mó cả user vào marketplace post và social đấy thì cái viết kiểu như này Thứ nhất Nó sẽ rất là khó nó rất là khó để bạn thay đổi cái data s của từ cái từ cái strock này sang cái strock khác của C một interface cái thứ hai đó là Đấy viết Nói chung là viết kiểu như này không Cái vấn đề chính đó bạn không th thay đổi được không thay đổi được là cái đối tượng dependency mà bạn sử dụng nó là cái gì đấy thì thay vì bạn viết như vậy Thay vì mình viết như thế này thì mình sẽ viết theo kiểu khác mình sẽ ủy thác cho cái việc khởi tạo social logic và marketplace logic sang bên ngoài và thằng server chỉ biết là nó lấy hai này thôi tương tự như thế thì ở phía marketplace logic cũng tương tự như thế new market logic đấy thì nó sẽ cần ba cái này đúng không Mình sẽ cho nó lấy ba cái này đó nhìn chú đến đoạn này các bạn có thể mình nghĩ là đến đạn này các bạn th hiểu được nó sẽ nhìn trông như thế nào rồi đấy Thì lúc này giả sử cái social logic của mình nếu bây giờ mình muốn test server và mình muốn móc cái user data accessor thì mình có thể cung cấp cái social logic và marketplace logic từ bên ngoài miễn là nó tuân thủ cái cái interface của mình đấy thì lúc đấy mình có thể cung cấp Cái móc của hai cái này mình sẽ không cần phải can thiệp mình không cần phải sửa lại cái code của hàm new Server này nữa mình có thể dùng trực tiếp cái new Server này Nhưng mà mình cung cấp cái đối tượng móc cái cung cấp cái mà đã được móc rồi đấy cũng tương tự như thế với cả marketplace logic nếu mà mình muốn test về user data accessor mà đã được móc thì mình sẽ sử dụng cái móc đấy thay vì là mình khởi tạo Thay vì mình chỉ sửa bên trong cái hàm này đấy Thì đấy là cái cái cái cách viết code như thế này Nó là một cái design patter Nó là một cái patter có tên gọi là dependency injection đó là inject chê cái dependency từ bên ngoài vào đấy thì cái nhược điểm của dependency injection là các bạn thấy là cái quá trình khởi tạo Nó sẽ rất là dài bạn kéo cái quá trình khởi tạo từ bên trong cái hàm new server này bạn kéo nó ra bên ngoài cái hàm main nó sẽ rất là dài tổng số lượng dòng Nó là như thế này đấy thì cái cách thì nhưng mà cái điểm mà chúng ta có thể cảm thấy may mắn ở đây đó là cái quá trình viết tất cả những cái dòng này nó có thể được tự động hóa và cái tự động hóa đ depy injection thì thường chúng ta sử dụng những cái dependency injection Framework như ở bên phía Go thì cái thứ mà mình hay sử dụng nó sẽ là w Google wi Google wi cho phép bạn có thể sinh ra được cái code dependency injection mình có thể cho các bạn thấy ở trong dự án cato của mình thì trong dự án cato của mình thì cái code dependency injection của mình nằm ở đây đây như các bạn thấy thì đối với cú pháp của w w sẽ là bạn sẽ tuyên bố các set bạn sẽ tên B set wiset Nó là một TP một tập hợp của những cái ví dụ như cái un wiset chở đâ hạn thì cái ulet đấy nó Định nghĩa trong cái file này các bạn sẽ thấy là cái file này nó Định nghĩa là trong cái thư viện utility của mình trong cái thư viện utility của mình thì sẽ có ví dụ như trong cái thư viện logic nà mình có rất nhiều cái mạng mình có rất nhiều cái phần logic ở trong dự án mình đúng không ở đây mình có logic liên quan đến quản lý account người dùng logic liên quan đến việc compile code qua logic đến việc chấm bài logic của việc quản lý bài tập chẳng hạn thì mình sẽ lưu tất cả những cái danh sách logic đấy nằm trong wirs đó mình dùng wiet để mà tổng hợp hết tất cả những cái struck mà mình có ở trong dự án như cái wiset này là tổng hợp hết tất cả những cái stru có ở trong cái package logic này đối với phía wi thì nó sẽ chỉ biết nó sẽ biết là ok có danh sách tất cả những cái strock này này ở trong utility ở trong config ở trong data asset ở trong logic ở trong handler đấy công việc của mình là mình sẽ báo với đó ra là mày hãy sinh ra cho tao một cái hàm có tên là initialize host nó nhận vào một cái thứ duy nhất là cái đường dẫn tới file config và một danh sách những cái argument mà mình truyền vào từ phía commandline và công việc của nó sẽ sinh ra một cái đối tượng là cái server host của mình cộng thêm hai cái function nữa là để Clean Up cái function này mình sẽ defer và một cái erot erot này sẽ báo lỗi nếu như mà có lỗi gì sinh ra trong quá trình khởi tạo đấy thì cái file này như các bạn thấy ở đây nó sẽ có một cái built built ở đây nó sẽ đánh dấu là cái file này nó sẽ không được nằm nó sẽ không được bao hàm nó sẽ không được bao hàm vào trong cái quá trình Build của bạn và nó sẽ sinh ra cái file này file này sẽ được bao hàm cho quá trình view và nó sinh ra tất cả những cái bước khởi tạo tất cả những cái đối tượng ở trong dự án của bạn và nó inject đúng cái dependency A và những cái chỗ Cần cần nó nếu mà a cần b thì b sẽ được inject vào đúng vị trí của A tất cả những cái dòng này tất cả những quá trình khởi tạo tất cả đối tượng trong dự án của bạn là được tự động hóa bởi thư viện wi của Google như vậy bạn có thể sử dụng được dependency injection bạn sử dụng được tất cả những cái cơ chế hay ho của nó như là việc bạn có thể inject m dependency và mục đích dễ dàng mà bạn vẫn có thể tự động hóa được cái quá trình khởi tạo dự án C đây là code do w sinh ra cho mình và khi mà mình muốn sử dụng cái file này thì mình sẽ vào hàm main của mình và mình sẽ chỉ cần là đọc những cái argument mà mình có ở trong phía cand Line và mình gọi hàm initial worker để mà start Cái app của mình ở đây đó như vậy toàn bộ quá trình khởi tạo giá mình mình không phải viết Thục công nữa mình để qu tự động hóa cho mình đó thì đây là một cái thư viện Rất là hay và đây là một cái pattern dependency injection là cái pattern tốt nhất mà mình có thể nói ở trên mọi ngôn ngữ vì nó giúp bạn cách biển cái việc mà một cái đối tượng A Cần đối tượng B nhưng bạn tách Việt được tách biệt được cái việc đấy ra khỏi cái việc đối tượng A khởi tạo đối tượng b a không cần phải khởi tạo đối tượng b a chỉ cần biết là A Cần b thôi Thế lúc đấy B được khởi tạo như thế nào không ai cần biết nữa dependency injection cho phép bạn là sử dụng bạn không cần phải khởi cho phép bạn có thể thay thế đối tượng B theo cách mà bạn muốn ví dụ như là thay vì dùng myle bạn dùng postc hoặ thay vì dùng postc bạn dùng mó và nó cũng đạt là chỉ có một đối tượng duy nhất tồn tại trong suốt cả dự án bạn có nghĩa là nếu mà các bạn code Java và các bạn nghe th cái từ S lon thì các bạn sẽ không cần phải dùng s lon trong Go hoặc không phải dùng selon nữa nếu bạn C theo cú pháp dependen injection thì đây là một cái cú pháp Đây là một cái design pattern mà mình muốn là các bạn sẽ ghi nhớ và các bạn sẽ cố gắng là sử dụng không chỉ trong Go sẽ dùng trong các ngôn ngữ khác và khi mà các bạn dùng tr các ngũ khác thì chắc chắn sẽ có những cái thư viện giống như gu để phậ tức động hóa được cái quá trình dependency injection của bạn ở trong dự án và các bạn sẽ không để mà các bạn có thể tập trung code cái logic Nhiệp vụ các bạn mình sẽ gửi link đến cái thư viện wi này ở trong cái chat của chat của lớp đấy thì ok mình vừa đi qua dependency injection dependency injection là một cái design pp cho phép bạn viết code để mà tách biệt được cái việc A Cần B khỏi cái việc A khởi tạo B và giúp cho bạn có thể dễ dàng Thay đổi cái b dựa trên cái hoàn cảnh mà các bạn cần sử dụng thì có bạn nào có câu hỏi gì liên quan đến dependency injection và liên quan đến w Ok Ok Bây giờ đã là 4 gi kém 7 phút rồi Ok mình nghĩ là mình đã đi qua tất cả mình đi qua những cái mục quan trọng nhất mà mình cần phải nói rồi mình vẫn chưa kịp đi qua một cái mục khác mà mình muốn nói ở trong Go thì ở trong Go những cái mà mình vừa nói là liên quan đến nó mang tính functional nó liên quan đế tính nó liên quan đến cái fature của Go khi mà các bạn ở trong dự án Go thì các bạn có thể muốn sử dụng những cái tool linter linter đảm bảo code của bạn nó tuân theo cái chuẩn tuân theo cái chuẩn cú pháp mà các bạn đặt ra cho dự án ví dụ như là bạn muốn đả bảo code của bạn không có bị sai Lỗ Chính tạo hoặc là bạn muốn đả bảo rằng là nhắc nhở với lập trình viên rằng tất cả những Eros tất cả những cái đối tượ erot mà được thow ra thì đều cần phải được kiểm tra kiểm tra xem nó có new hay không Nếu không new thì sẽ như thế nào đấy thì cái tool linter cái thư viện linter mà được sử dụng à Cái tool linter mà mình mà mình sử dụng chuẩn trong go Nó gọi là Go ci Link và Go C link nó là Go C link là cái thư viện mà mình sẽ sử dụng để mà mình cài đặt cái để mình cài đặt cái cơ chế check Link ở trong dự án của mình kiểm tra xem là cái dự án của mình có đã đủ cái tiêu chuẩn mỹ thuật mà mình đặt ra Hay không Cái này là cái nó không nằm ở trong cái thư viện chuẩn của Go nhưng mà nó sẽ là cái mà chắc chắn là các bạn phải dùng trong dự H của mình rồi chắc chắn là các bạn sẽ cài đặt linter Để kiểm tra xem code của bạn có đạt chuẩn hay không Hay là có cái lỗi gì mà sơ hở có thể dễ dàng tránh được bằng ler không thì khá năng cao bạn sẽ cần Phả cà thư biện này anh ơi trong mấy Framework nổi của Go có sẵn cái Di chưa Hay mình cần vẫn cần cài thêm thư viện ng chưa Go không Tức là bạn có thể viết dependency injection bạn không cần Why dependen chỉ là một cái design part thôi và các bạn có thể viết một cách thủ công Why chỉ tự động hóa cái quá trình sinh ra cái sinh ra cái chuỗi khởi tạo của của dependen injection thôi đó nên là Go không đóng gói wi vào trong dự án Tuy nhiên tuy nhiên các bạn có thể Tuy nhiên các bạn có thể cài đặt Wi từ bên ngoài và các bạn có thể cài Wi và các bạn thể sử dụng cái t Go generate ở đây để mà chạy cái câu lệnh w lên trên cái file y.co của bạn ngoài w ra thì cũng có những cái giải pháp khác ví dụ như là Uber FX Uber FX cũng là một cái dependency injection system của Go và cái này thì được sử dụng bởi Uber rõ ràng rồi khác biệt cái điểm khác biệt giữa Uber FX và Why nó là Why nó sẽ Why là sinh ra code Why gen code Tức là cái file này cái file này nó sẽ nằm ở trong cái nó sẽ được sinh ra trước khi bạn compile code và bạn có thể kiểm tra cái file này bạn có thể đọc cái file này để mà kiểm tra xem có lỗi gì sinh ra hay không trái ngược với cả y thì Uber FX là runtime dependency injection có nghĩa là là cái logic để mà cung cấp cái A cho cái B nó được thực hiện trong quá trình chạy chương trình Go của bạn tức là sau khi bạn đã compile C rồi điều đấy có nghĩa là nếu mà có một cái Black Magic gì đó nếu mà cái thư viện này có bớ thì lúc này bạn sẽ không thể kiểm tra được qua quá trình compile code và có nghĩa là cái việc mà dependency injection Bởi cái thư viện FX này nó sẽ là thư viện runtime dependency injection chứ không phải là compile time dependency requ nữa mình chưa có nhu cầu gì cần phải sử dụng đến runtime dependency injection cả mình viết có một số cái dự án mà sẽ cần phải có runtime dependen injection ví dụ như là các bạn viết serverless và serverless cần phải có cái A cái A Cần cái B nhưng mà cái A Cần cái b đấy là được được tuyên bố bởi những người sử dụng cái binary của bạn thì lúc này cái này sẽ là cái quan trọng và phải dùng cái này chứ không thể dùng Wi nữa nhưng bình thường mình dùng w bởi vì mình muốn sin code và mình muốn mình muốn sinh code mà mình muốn có thể kiểm tra được cái code mà mình sinh ra thay vì là for thay là việc phụ để hết tất cả những cái này cho một cái thư viện chạy trong lúc run à Đấy cũng là cái lý do vì sao mà mình thích cái ngôn ngữ compile time static check như là Go thay vì là JavaScript các bạn biết là có JavaScript là có times Script và times Script là cho phép bạn TPT các bạn biết là times Script nó là ngôn ngữ ngôn ngữ Java nó một cái suet của Java phé Bạn có thể viết code mà có kiểm tra time có kiểm tra time chặt dụ ở đây là báo lỗi là type name ở đây là theo kiểu dữ liệu type ở đây là cái name Ở đây nó không nằm trong cái str này đấy thì Script nó là nó cũng cho phép bạn có thể có compile time compile time checking đấy nó khác với cả Java là nếu bạn muốn kiểm tra ty thì bạn kiểm tra trong lúc run time bạn phải biết logic ra kiểm tra xem là một cái Đối Thượng này có phải là string không hay nó là number hay là Bullet đấy thì mình sẽ thích những cái compile time dependen compile time checking như thế này hơn là runtime bởi vì runtime nghĩa là bạn phải chạy code này ra rồi thì lúc đấy bạn mới biết là cái code của bạn có sai không đúng không cái này mình V angular angular đóng gói cả time Script và nó đóng gói cả dependency injection angular có đóng gói một cái cơ chế depend một cái cơ chế inject riêng của nó mà mình không thể sử dụng được ở phía bên ngoài thì mình cũng thích dùng angol mình thích dùng angol hơn dùng react mình chưa dùng vu bao giờ nhưng mà mình thích dùng angular hơn dùng react bởi vì là angular cung cấp cơ chế sin code là một nhá Cái này là như các bạn có thể nghe thấy mình nói là mình rất thích sy code rồi mình vẫ tự hóa công việc của mình và cái thứ hai là nó có dependency injection đấy cũng là một cái mình rất thích đấy Thì đấy là mình thích dùng angular hơn dùng react nhưng mà angular không bao giờ nhận được đủ cái sự recognize đáng mà nó lẽ ra lên có angular nó nó nó chặt chẽ nó ổn định hơn vx rất là nhiều và mình cảm thấy rất bất công là Angle không phổ biến bằng reax nếu mà các bạn dùng JavaScript hoặc t Script thì các bạn sẽ muốn sử dụng brandy brandy là cái cơ chế là cái thư viện dependency injection mà mình sử dụng cho t Script đó learning curve của nó khó hơn r à giữa trên tất cả những cái đống thư viện như là nextjs à Xong rồi nextjs để mà viết react lên trên để mà Framework dành cho react hoặc là ví dụ như casb 1 tỷ cái thư viện xoay quanh cái react hoặc là ví dụ như tất cả những cái chuyện đang xảy ra với cả create react app thì mình nghĩ là cái learning curve của react mình chưa từng phải đặt nhau nhiều như thế này đối với cả dự án của angular so yeah Nếu react re nhiều khi ta chọn react bởi vì nó là cái thứ phổ biến nhất nhưng mà đây dự án này mình viết bằng angular này đây web vscode package.js đây angular đây đó đấy thì đây là tất cả những kiến thức mà mình muốn nói qua về ngôn ngữ Go Chúng ta đã đi qua về C pháp của Go Chúng ta đã đi qua về những cái tính năng đặc biệt của Go khiến cho nó trở nên mạnh mẽ như là Go routine như là defer mình hôm nay bữa hôm nay chúng ta đã đi qua về cái Framework test của Go nó Build in cùng với trạ ngôn ngữ của go và những cái thư viện mà các bạn thể sử dụng để mà làm cho cái quá trình test bằng ngôn ngữ Go của bạn tiện lợi hơn buổi hôm sau chúng ta sẽ học về database và buổi hôm sau thì mình sẽ nói nhiều hơn về cái cách mà mình thiết kế database ở trong dự án backend và cách mà các bạn sẽ tương tác với database ở trong dự án backend qua ng ngữ go đó bữa sau V bình thường nhá th thôi à Không bạn nào có câu hỏi gì gì Tạm biệt các bạn Hẹn bổi sau Bye bye